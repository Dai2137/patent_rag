{
    "doc_number": "2023052340",
    "invention_title": "イントラブロックコピーモードとインター予測ツールとの間の相互作用",
    "abstract": "【課題】本開示は、イントラブロックコピーモードとインター予測ツールとの間の相互作用に関する。 【解決手段】ビデオ処理のための方法が提供される。本方法は、ビデオの現在ビデオブロックに対してイントラブロックコピー（IBC）モードが適用されることを決定するステップであり、前記IBCモードにおいて、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ビデオブロックが配置されている現在ピクチャである、ステップと、前記現在ブロックに対する特定のコーディングモードをディセーブルすることに関する決定を行うステップと、前記決定に基づいて、前記現在ビデオブロックとビットストリーム表現との間で変換を実行するステップと、を含み、前記特定のコーディングモードは、ビデオブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する。 【選択図】 図２９",
    "claims": [
        "【請求項1】ビデオデータを処理する方法であって、 ビデオの現在ビデオブロックに対してイントラブロックコピー（ＩＢＣ）モードが適用されることを決定するステップであり、前記ＩＢＣモードにおいては、前記現在ビデオブロックを含むビデオ領域からの参照サンプルが使用される、ステップと、 前記決定に基づいて、前記現在ビデオブロックと前記ビデオのビットストリームとの間の変換を実行するステップと、 を含み、 前記ＩＢＣモードは、ルマ成分およびクロマ成分が別々のコーディング構造ツリーでコード化される、デュアルコード化ツリーを有するビデオブロックに適用される、 方法。",
        "【請求項2】前記方法は、さらに、 前記現在ビデオブロックについて特定の符号化モードをディセーブルすることに関する決定を行うステップ、 を含む、請求項１記載の方法。",
        "【請求項3】前記特定の符号化モードのフラグが、前記現在ビデオブロックで使用されている前記ＩＢＣモードに応答して前記ビットストリームに含まれていない、 請求項２記載の方法。",
        "【請求項4】前記フラグが前記ビットストリームに含まれない場合、前記フラグはゼロであると推定される、 請求項３記載の方法。",
        "【請求項5】前記特定の符号化モードは、ＣＵレベルの重み付けモードを用いる双予測を含み、前記ＣＵレベルの重み付けモードを用いる双予測において、異なる重み付け値は、予測の導出プロセスにおける異なる参照画像に関連する、 請求項２乃至４いずれか一項に記載の方法。",
        "【請求項6】ＣＵレベルの重み付けモードを用いる前記双予測の重み付けインデックスが、前記現在ビデオブロックで使用されている前記ＩＢＣモードに応答して前記ビットストリームに含まれていない、 請求項５に記載の方法。",
        "【請求項7】前記重み付けインデックスが前記ビットストリームに含まれない場合、重み付けインデックスはゼロであると推定される、 請求項６に記載の方法。",
        "【請求項8】前記特定の符号化モードは、動きベクトル差異（ＭＭＶＤ）モードとのマージを含み、 前記ＭＭＶＤモードにおいて、ビデオブロックの動きベクトルは、マージ動き候補リストに基づいて導出され、かつ、少なくとも１つの動きベクトルオフセットによってさらに精密化される、 請求項２乃至７いずれか一項に記載の方法。",
        "【請求項9】前記特定の符号化モードは、アフィンモード、および、結合されたインター－イントラ予測モードを含み、 前記アフィンモードは、少なくとも１つの制御点動きベクトルを使用し、 前記結合されたインター－イントラ予測モードにおいては、中間イントラ予測信号および中間インター予測信号の加重和に少なくとも基づいて最終予測が生成される、 請求項２乃至８いずれか一項に記載の方法。",
        "【請求項10】前記特定の符号化モードは、サブブロックベースの時間的動きベクトル予測モードを含み、 前記サブブロックベースの時間的動きベクトル予測モードにおいて、少なくとも１つの時間的な動きオフセットによって決定される配置領域に基づいて、動き情報が導出される、 請求項２乃至９いずれか一項に記載の方法。",
        "【請求項11】前記実行するステップの前に、前記方法は、さらに、 前記現在ビデオブロックについてブロックベクトルを導出するステップと、 前記ブロックベクトルを精密化するために、前記ビットストリームに含まれる少なくとも１つのブロックベクトル差異を使用するステップと、を含む、 請求項１乃至１０いずれか一項に記載の方法。",
        "【請求項12】前記現在ビデオブロックの幅は２以上であり、かつ、高さは２以上である、 請求項１乃至１１いずれか一項に記載の方法。",
        "【請求項13】前記変換は、前記ビットストリームから前記現在ビデオブロックを復号化することを含む、 請求項１乃至１２いずれか一項に記載の方法。",
        "【請求項14】前記変換は、前記現在ビデオブロックを前記ビットストリームへと符号化することを含む、 請求項１乃至１２いずれか一項に記載の方法。",
        "【請求項15】プロセッサ、および、命令が保管された非一時メモリを備えるビデオデータを処理するための装置であって、 前記プロセッサによって、前記命令が実行されると、前記プロセッサに、 ビデオの現在ビデオブロックに対してイントラブロックコピー（ＩＢＣ）モードが適用されることを決定し、前記ＩＢＣモードにおいては、前記現在ビデオブロックを含むビデオ領域からの参照サンプルが使用され、 前記決定に基づいて、前記現在ビデオブロックと前記ビデオのビットストリームとの間の変換を実行する、 ようにさせ、 前記ＩＢＣモードは、ルマ成分およびクロマ成分が別々のコーディング構造ツリーでコード化される、デュアルコード化ツリーを有するビデオブロックに適用される、 装置。",
        "【請求項16】命令を保管する非一時なコンピュータで読取り可能な記憶媒体であって、 前記命令が実行されると、プロセッサに、 ビデオの現在ビデオブロックに対してイントラブロックコピー（ＩＢＣ）モードが適用されることを決定し、前記ＩＢＣモードにおいては、前記現在ビデオブロックを含むビデオ領域からの参照サンプルが使用され、 前記決定に基づいて、前記現在ビデオブロックと前記ビデオのビットストリームとの間の変換を実行する、 ようにさせ、 前記ＩＢＣモードは、ルマ成分およびクロマ成分が別々のコーディング構造ツリーでコード化される、デュアルコード化ツリーを有するビデオブロックに適用される、 非一時なコンピュータで読取り可能な記憶媒体。",
        "【請求項17】ビデオ処理装置によって実行される方法によって生成されたビデオのビットストリームを保管する非一時的なコンピュータで読取り可能な記憶媒体であって、 前記方法は、 ビデオの現在ビデオブロックに対してイントラブロックコピー（ＩＢＣ）モードが適用されることを決定するステップであり、前記ＩＢＣモードにおいては、前記現在ビデオブロックを含むビデオ領域からの参照サンプルが使用される、ステップと、 前記決定に基づいて、前記現在ビデオブロックから前記ビットストリームを生成するステップと、 を含み、 前記ＩＢＣモードは、ルマ成分およびクロマ成分が別々のコーディング構造ツリーでコード化される、デュアルコード化ツリーを有するビデオブロックに適用される、 非一時的なコンピュータで読取り可能な記憶媒体。"
    ],
    "description": {
        "technical_field": [
            "本特許文書は、ビデオコーディング技術、装置、およびシステムに関する。",
            "本出願は、2018年11月29日に出願された国際特許出願第PCT/CN2018/118167号について優先権および利益を主張する。国際特許出願第PCT/CN2018/118167号の全ての開示は、この出願の開示の一部として参考により組み込まれている。"
        ],
        "background_art": [
            "ビデオ圧縮における進歩にもかかわらず、デジタルビデオは、インターネットおよび他のデジタル通信ネットワークにおいて、依然として最大の帯域幅の割合を占めている。ビデオの受信および表示が可能な接続されたユーザデバイスの数が増加するにつれて、デジタルビデオの利用に対する帯域幅需要は増加し続けることが予想されている。"
        ],
        "disclosure": {
            "tech_problem": [
                "デジタルビデオコーディング（coding）、そして特には、ビデオおよび映像のコーディングにおける、動きベクトル（motion vector）の導出、および、イントラブロックコピー(Intra-Block-Copy、IBC)のためのシグナリング（signaling）が説明される。説明される方法は、既存のビデオコーディング標準(例えば、高効率ビデオコーディング（HEVC）)、および、将来のビデオコーディング標準またはビデオコーデック、の両方に適用され得る。"
            ],
            "tech_solution": [
                "１つの代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、ビデオの現在ビデオブロックに対してイントラブロックコピー（IBC）モードが適用されることを決定するステップであり、前記IBCモードにおいて、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ビデオブロックが配置されている現在ピクチャである、ステップと、記現在ビデオブロックに対する特定のコーディングモードをディセーブルすることに関する決定を行うステップと、前記決定に基づいて、前記現在ビデオブロックとビットストリーム表現との間で変換を実行するステップと、を含み、前記特定のコーディングモードは、ビデオブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する。",
                "別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックが特定のコーディングモードを使用して符号化されることを決定するステップと、前記決定に基づいて前記現在ブロックについてイントラブロックコピー（IBC）モードをディセーブルすることに関する決定を行うステップであり、前記IBCモードにおいて、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ブロックが配置されている現在ピクチャである、ステップと、前記決定に基づいて、前記現在ブロックとビットストリーム表現との間で変換を実行するステップと、を含み、前記特定のコーディングモードは、前記現在ブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックのアフィンモードを決定するステップであり、前記現在ビデオブロックが隣接ブロックからアフィンモードを継承するか否かは、参照リストに依存する、ステップと、ビデオの現在ビデオブロックと、前記決定に基づいて一貫したビデオのビットストリーム表現との間の変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、ビデオの現在ビデオブロックと、前記現在ビデオブロックのビットストリーム表現との間の変換を実行するステップ、を含み、前記変換の最中には、イントラブロックコピー（IBC）モード、および、動きベクトル差異とのマージ（MMVD）モードが使用される。そして、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、前記MMVDモードでは、ビデオブロックの動きベクトルが、マージモーション候補リストに基づいて導出されて、さらに、少なくとも１つの動きベクトル差異によって精密化される。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、ビデオの現在ビデオブロックと前記ビデオのビットストリーム表現との間の変換を実行するステップ、を含み、前記変換の最中には、イントラブロックコピー（IBC）モードおよびインター－イントラ予測モードが使用される。そして、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、前記インター－イントラ予測モードでは、前記現在ビデオブロックの予測信号は、少なくともイントラ予測信号およびインター予測信号に基づいて生成される。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の最中に、IBCモードとは異なる少なくとも１つのコーディング方法のデコードされた情報を決定するステップであり、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックがその中に配置されている現在ピクチャである、ステップと、前記デコードされた情報に基づいて、前記現在ビデオブロックのビットストリーム表現における前記現在ビデオブロックについてIBCフラグのシグナリングをスキップするか否かを決定するステップであり、前記IBCフラグは、IBモードに関連する、ステップと、前記決定に基づいて、前記変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の最中に、前記現在ビデオブロックは、第１コーディング構造ツリーを使用してコード化されるルマ成分、および、前記第１コーディング構造ツリーとは異なる第２コーディング構造ツリーを使用してコード化されるクロマ成分を含み、前記現在ビデオブロックの前記ルマ成分の１つ以上の対応するブロックに係る第２動きベクトル情報からクロマブロックに対する第１動きベクトル情報を導出する、ステップと、前記第１動きベクトル情報および前記第２動きベクトル情報に基づいて、前記変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックが配置されているピクチャと同一であるイントラブロックコピーモード（IBC）を前記現在ビデオブロックに適用するかどうかを決定するステップと、前記IBCモードが前記現在ビデオブロックに適用されるかどうかをシグナリングするステップと、前記IBCモードが前記現在ビデオブロックに適用されることを決定することに基づいて、予測モードのグループに対するシグナリングフラグを控えるステップと、前記IBCモードの適用に基づいて、前記現在ビデオブロックの変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、ビットストリームを解析して、現在ビデオブロックによって使用されている少なくとも１つの参照ピクチャが、現在ビデオブロックが配置されているピクチャと同一であるかどうかを判定するステップと、現在ビデオブロックに対して変換を実行するステップとを含み、ここで、予測モードのグループに対するフラグは、CPRが現在ビデオブロックに対して適用されることを判定することに基づいて、ビットストリームから除外される。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックの動き情報を取得するプロセスにおいて、前記現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の間に、前記現在ビデオブロックの前記動き情報が、前記現在ビデオブロックの少なくとも１つの隣接するブロックの少なくとも１つのアフィンモデルに基づいており、前記現在ビデオブロックの隣接するブロックが、前記隣接するビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記隣接するブロックが配置されているピクチャと同一であるイントラブロックコピーモード（IBC）を使用するかどうかを決定するステップと、前記現在ビデオブロックに対して、前記隣接するビデオブロックが前記IBCモードを使用することを決定することに基づいて、前記隣接するブロックからアフィン候補を導出することを無効にするステップと、前記変換を、前記現在ビデオブロックの動き情報に基づいて実行するステップとを含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、現在ビデオブロックを、サブブロックに基づく時間的動きベクトル予測(SbTMVP)モードに基づく現在ビデオブロックのビットストリーム表現との間の変換の最中に、サブブロックに分割するステップと、現在ビデオブロックの空間的隣接ブロックの動き情報に基づいて、時間的ベクトルを有する動きソースピクチャにおいて、対応するブロックを識別するステップと、前記サブブロックの対応するブロックのコーディングモード情報に基づいて、前記サブブロックの動きベクトルおよび参照インデックスを前記サブブロックの前記対応するブロックから生成するステップと、前記生成された動きベクトルおよび参照インデックスに基づいて前記変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、開示される技術は、ビデオ処理のための方法を提供するために使用され得る。この方法は、サブブロックベースの時間的動きベクトル予測(SbTMVP)モードに基づいて、現在ビデオブロックと現在ビデオブロックのビットストリーム表現との間の変換の最中に、現在ビデオブロックをサブブロックに分割するステップと、現在ビデオブロックの空間的隣接ブロックのコーディングモード情報に基づいて、時間的ベクトルを有する動きソースピクチャにおいて、対応するブロックを識別するステップと、前記サブブロックの対応するブロックから、前記サブブロックの動きベクトルおよび参照インデックスを生成するステップと、前記生成された動きベクトルおよび参照インデックスに基づいて前記変換を実行するステップと、を含む。",
                "さらに別の代表的な態様において、上述の方法は、プロセッサで実行可能なコードの形態で具現化され、そして、コンピュータで読取り可能なプログラム媒体に保管される。",
                "さらに別の代表的な態様において、上述の方法を実行するように構成され、または動作可能なデバイスが開示される。本装置は、この方法を実装するようにプログラムされたプロセッサを含んでよい。",
                "さらに別の代表的な態様において、ビデオデコーディング装置は、ここにおいて説明される方法を実装することができる。",
                "開示される技術に係る上記の態様および特徴は、図面、明細書、および請求項においてより詳細に説明される。"
            ],
            "advantageous_effects": []
        },
        "best_mode": [
            "より高分解のビデオに対する要求が増加しているため、ビデオコーディング方法および技術は、現代の技術においては至る所に姿を現している（ubiquitous）。ビデオコーデック（codec）は、典型的には、デジタルビデオを圧縮（compress）または解凍（decompress）する電子回路またはソフトウェアを含み、そして、より高いコード化効率を提供するために継続的に改良されている。ビデオコーデックは、圧縮されていないビデオを圧縮されたフォーマットへと変換し、また、その逆も同様である。ビデオ品質、ビデオを表現するために使用されるデータ量(ビットレートによって決定される)、符号化および復号化アルゴリズムの複雑性、データ損失およびエラーに対する感度、編集の容易さ、ランダムアクセス、および、エンドツーエンド遅延(レイテンシ（latency）)の間には複雑な関係性が存在している。圧縮フォーマットは、たいてい、標準的なビデオ圧縮仕様に準拠している。例えば、高効率ビデオコーディング(High Efficiency Video Coding、HEVC)規格(H.265またはMPEG-H Part2としても知られている)、最終化される汎用ビデオコーディング規格（Versatile Video Coding）、または、他の現在及び／又は将来のビデオコーディング規格、である。",
            "開示される技術の実施形態は、既存のビデオコーディング標準(例えば、HEVC、H.265)、および、圧縮性能を改善するために将来の標準に対して適用され得る。セクション見出し（heading）が、説明の可読性を向上させるために、本文書では使用されており、そして、いかなる場合も、説明または実施形態(及び／又は、実装)をそれぞれのセクションだけに限定するものではない。",
            "本文書において、用語「ビデオ処理（“video processing”）」は、ビデオコーディング、ビデオデコーディング、ビデオ圧縮、またはビデオ解凍を参照し得る。例えば、ビデオ圧縮アルゴリズムは、ビデオのピクセル表現から対応するビットストリーム表現への変換の最中に適用され得る。また、その逆も同様である。",
            "１ HEVC/H.265におけるインター予測の例 ビデオコーディング規格は、長年にわたり著しく改良されてきており、そして、今や、部分的には、高いコード化効率を提供し、かつ、より高い分解をサポートしている。HEVCおよびH.265といった、最近の標準は、ハイブリッドビデオコーディング構造に基づいており、そこでは、時間的予測プラス（plus）変換符号化が利用されている。",
            "１．１ 予測モードの例 各インター予測PU(予測ユニット（prediction unit）)は、１つ又は２つの参照ピクチャ（reference picture）リストのための動きパラメータを有する。いくつかの実施形態において、動きパラメータ（motion parameter）は、動きベクトルおよび参照ピクチャインデックスを含んでいる。他の実施形態において、２つの参照ピクチャリストのうちの１つの使用は、また、inter_pred_idcを使用して信号化されてもよい。さらに他の実施形態において、動きベクトルは、予測子（predictor）に対するデルタとして明示的に符号化されてよい。",
            "CUがスキップモードで符号化される場合、１つのPUがそのCUに関連付けられ、そして、有意な（significant）残差係数（residual coefficient）、符号化動きベクトルデルタまたは参照ピクチャインデックスは存在しない。マージモード（merge mode）が指定され、それにより、空間的候補および時間的候補を含む、現在PUについての動きパラメータが、隣接するPUから獲得される。マージモードは、スキップモードだけでなく、任意のインター予測（inter-predicted）PUに対して適用され得る。マージモードの代替は、動きパラメータの明示的な伝送であり、ここで、動きベクトル、各参照ピクチャリストについて対応する参照ピクチャインデックス、および参照ピクチャリストの使用は、各PUごとに明示的に信号化（signaled）される。",
            "２つの参照ピクチャリストの１つが使用されるべきであることを信号化（signaling）が示している場合に、PUは、サンプルの１つのブロックから生成される。これは、「単一予測（“uni-prediction”）」として参照される。単一予測は、ＰスライスおよびＢ－スライスの両方について利用可能である。",
            "参照ピクチャリストの両方が使用されるべきであることを信号化が示している場合に、PUは、サンプルの２つのブロックから生成される。これは「双予測（“bi-prediction”）」として参照される。双予測は、Ｂ－スライスだけについて利用可能である。",
            "参照ピクチャリスト",
            "HEVCにおいて、インター予測という用語は、現在の復号化ピクチャ以外の参照ピクチャデータ要素(例えば、サンプル値または動きベクトル)から導出される予測を示している。H.264/AVCと同様に、複数の参照ピクチャから１つのピクチャが予測され得る。インター予測のために使用される参照ピクチャは、１つ以上の参照ピクチャリストにおいて整理されている。参照ピクチャインデックスは、リスト内の参照ピクチャのうち、予測信号を生成するために使用すべきものを識別する。",
            "単一の参照ピクチャリスト、List0がＰスライスについて使用され、そして、２つの参照ピクチャリスト、List0およびList1がＢ－スライスについて使用され。List0/List1に含まれる参照ピクチャは、キャプチャ（capturing）／表示に関して過去および将来のピクチャからのものであり得る。",
            "１．１．１ マージモードについて候補を構築する実施形態 マージモードを使用してPUが予測される場合には、マージ候補リスト内のエントリーを指し示すインデックスがビットストリームから構文解析（parsed）され、そして、動き情報を取り出す（retrieve）するために使用される。このリストの構成は、以下のステップのシーケンスに従って要約され得る。",
            "ステップ１：初期候補の導出 ステップ１．１：空間的候補の導出 ステップ１．２：空間的候補について冗長性（redundancy）チェック ステップ１．３：時間的候補の導出 ステップ２：追加候補の挿入 ステップ２．１：:双予測候補の作成 ステップ２．２：ゼロ（zero）動き候補の挿入",
            "図1は、上に要約されたステップのシーケンスに基づいてマージ候補リストを構築する一つの例を示している。空間的マージ候補導出のために、５つの異なる位置に配置された候補の中から最大４つのマージ候補が選択される。時間的マージ候補導出のために、２つの候補の中から最大１つのマージ候補が選択される。デコーダでは各PUについて一定の数の候補が仮定されているので、候補の数が、スライスヘッダ内で信号化されているマージ候補の最大数(MaxNumMergeCand)に到達しない場合に、追加候補が生成される。候補の数は一定なので、最良のマージ候補のインデックスは、切り捨て単項二値化(truncated unary binarization、TU)を使用して符号化される。CUのサイズが８に等しい場合には、現在CUの全てのPUは、2N×2N予測ユニットのマージ候補リストと同一である、単一のマージ候補リストを共有する。",
            "１．１．２ 空間的マージ候補の構築 空間的マージ候補の導出において、図2に示された位置に配置された候補の中から最大４つのマージ候補が選択される。導出の順序はA1、B1、B0、A0、B2である。位置B2は、位置A1、B1、B0、A0のうち任意のPUが利用できないか(例えば、それが別のスライスまたはタイルに属しているため)、または、イントラコード化されている場合にだけ考慮される。位置A1で候補が追加された後で、残りの候補の追加は、コード化効率が改善されるように、同一の動き情報を有する候補がリストから除外されることを保証する冗長性（redundancy）チェックの対象となる。",
            "計算の複雑性を低減するために、上記の冗長性検査においては、可能な候補ペアの全てが考慮されるわけではない。代わりに、図3において矢印を用いてリンクされたペアだけが考慮され、そして、冗長性チェックに使用される対応する候補が同じ動き情報を持たない場合にだけ候補がリストに追加される。重複した動き情報の別のソースは、2N×2Nとは異なるパーティションに関連付けられた「第２PU（“second PU”）」である。一つの例として、図4Aおよび図4Bは、それぞれ、N×2Nおよび2N×Nの事例（case）について第２PUを示している。現在PUがN×2Nに分割されている場合に、A1の候補はリスト構築において考慮されない。いくつかの実施形態において、この候補を追加することは、同一の動き情報を有する２つの予測ユニットに導くことがあり、これは、コーディングユニット内にただ１つのPUを有することに対して冗長である。同様に、現在PUが2N×として分割されている場合に、位置B1は考慮されない。",
            "１．１．３ 時間的マージ候補の構築 このステップにおいては、１つの候補だけがリストに追加される。特に、この時間的マージ候補の導出においては、スケーリングされた（scaled）動きベクトルが、所与の参照ピクチャリストの中で現在ピクチャとのPOC差異が最小であるピクチャに属する同一場所の（co-located）PUに基づいて導出される。同一場所のPUの導出に使用される参照ピクチャリストは、スライスヘッダ内で明示的に信号化される。",
            "図5は、一つの例示的な時間的マージ候補(点線として)に対するスケーリングされた動きベクトルの導出を示しており、それは、POC距離、tb、およびtdを使用して、同一場所のPUの動きベクトルからスケーリングされている。ここで、tbは、現在ピクチャの参照ピクチャと現在ピクチャとの間のPOC差異であると定義され、そして、tdは、同一場所のピクチャの参照ピクチャと同一場所のピクチャとの間のPOC差異であると定義されている。時間的マージ候補の参照ピクチャインデックスはゼロに等しく設定されている。Ｂ－スライスについては、２つの動きベクトル、一方は参照ピクチャリスト0そして他方は参照ピクチャリスト1、が獲得され、そして、組み合わされて、双予測（bi-predictive）マージ候補を作成する。",
            "参照フレームに属する同一場所のPU(Y)では、図6に示されるように、時間的候補の位置が候補C0とC1の間で選択される。位置C0でのPUが、利用可能でなく、イントラコード化されており、または、現在CTUの外側にある場合には、位置C1が使用される。そうでなければ、位置C0は、時間的マージ候補の導出に使用される。",
            "１．１．４ マージ候補の追加タイプの構築 空間的－時間的マージ候補の他に、マージ候補の２つの追加タイプが存在する。結合双予測（combined bi-predictive）マージ候補およびゼロマージ候補である。結合双予測マージ候補は、空間的－時間的マージ候補を利用することによって生成される。結合双予測マージ候補は、Ｂ－スライスだけに使用される。結合双予測候補は、初期候補の第１参照ピクチャリスト動きパラメータを、別の第２参照ピクチャリスト動きパラメータと組み合わせることによって生成される。これらの２つのタプル（tuple）が異なる動き仮説（hypotheses）を提供する場合に、それらは新たな双予測候補を形成する。",
            "図7は、このプロセスの一つの例を示している。ここでは、mvL0とrefIdxL0、または、mvL1とrefIdxL1を有する、元のリスト(左側の710)中の２つの候補が、最終リスト(右側の720)に追加された結合双予測マージ候補を作成するために使用される。",
            "マージ候補リスト内の残りのエントリーを埋めるためにゼロ動き候補が挿入され、そして、従ってMaxNumMergeCand容量に達する。これらの候補は、ゼロ空間的変位、および、ゼロから始まり、新たなゼロ動き候補がリストに追加される毎に増加する、参照ピクチャインデックスを有している。これらの候補によって使用される参照フレームの数は、単方向および双方向予測について、それぞれに、１および２である。いくつかの実施形態においては、これらの候補について冗長性検査は実行されない。",
            "いくつかの実施形態においては、以下のステップが、マージリストが満杯になるまで順番に実行される。 (1)変数numRefを、Ｐスライスについてリスト0に関連付けられた参照ピクチャの数、または、Ｂスライスについて２つのリスト内の参照ピクチャの最小数、のいずれかに設定する。 (2)非反復ゼロ動き候補の追加 0...numRef-1である変数iについて、リスト0(Ｐスライスの場合)または両方のリスト(Ｂ－スライスの場合)に対して、(0,0)に設定されたMVを伴うデフォルトの動き候補、および、iに設定された参照ピクチャインデックスを追加する。 (3)(0,0)に設定されたMVを伴う繰り返しゼロ（repeated zero）の動き候補、0に設定されたリスト0の参照ピクチャインデックス(Ｐスライスの場合)、および、0に設定された両方のリストの参照ピクチャインデックス(Ｂスライスの場合)を追加する。",
            "１．２ 高度な動きベクトル予測(AMVP)の実施形態 AMVPは、動きパラメータの明示的な伝送のために使用される、隣接PUを伴う動きベクトルの空間的－時間的相関を利用する。これは、最初に、左側、上の時間的に隣接するPU位置の利用可能性をチェックし、冗長な候補を除去し、そして、候補リストを一定長にするためにゼロベクトルを加えることによって、動きベクトル候補リストを構築する。次いで、エンコーダは、候補リストから最良の予測子（predictor）を選択し、そして、選択された候補を示している対応するインデックスを送信することができる。同様に、マージインデックス・信号化では、最良の動きベクトル候補のインデックスは、切り捨て単項(truncated unary)を使用して符号化される。この事例において符号化されるべき最大値は２である(図8参照)。以下のセクションでは、動きベクトル予測候補の導出プロセスに関する詳細が提供される。",
            "１．２．１ AMVP候補導出の実施例 図8は、動きベクトル予測候補について導出プロセスをまとめたものであり、そして、入力としてrefidxを用いて各参照ピクチャリストに対して実装され得る。",
            "動きベクトル予測においては、動きベクトル候補の２つのタイプが考察される。空間的動きベクトル候補および時間的動きベクトル候補である。空間的動きベクトル候補導出のために、２つの動きベクトル候補が、図2で先に示されたように、５つの異なる位置に配置された各PUの動きベクトルに基づいて、最終的に導出される。",
            "時間的動きベクトル候補導出のために、同一場所の２つの異なる位置に基づいて導出された、２つの候補から１つの動きベクトル候補が選択される。空間的－時間的候補の第１リストが作成された後で、リスト内の重複した動きベクトル候補が取り除かれる。可能性ある候補の数が２よりも多い場合に、関連する参照ピクチャリストの中の参照ピクチャインデックスが１よりも大きい動きベクトル候補は、リストから削除される。空間的－時間的動きベクトル候補の数が２より少ない場合には、追加のゼロ動きベクトル候補がリストに追加される。",
            "１．２．２ 空間的動きベクトル候補の構築 空間的動きベクトル候補の導出においては、５つの可能性ある候補の中で最大２つの候補が考慮され、それらの候補は、図2で先に示されたような位置に配置されたPUから導出されており、それらの位置は、動きマージのものと同じである。現在PUの左側に対する導出の順序は、A0、A1、および、スケーリングされたA0、スケーリングされたA1として定義される。現在PUの上側に対する導出の順序は、B0、B1、B2、スケーリングされたB0、スケーリングされたB1、スケーリングされたB2として定義される。従って、各側について、動きベクトル候補として使用され得る４つの事例が存在する。２つの事例は空間的スケーリングを使用する必要がなく、２つのケースでは空間的スケーリングが使用される。４つの異なる事例は、以下のようにまとめられる。 －空間的スケーリングなし (1)同一参照ピクチャリスト、および、同一参照ピクチャインデックス(同一POC) (2)異なる参照ピクチャリストであるが、同じ参照ピクチャ(同じPOC) －空間的スケーリング (3)同一の参照ピクチャリストであるが、異なる参照ピクチャ(異なるPOC) (4)異なる参照ピクチャリスト、および、異なる参照ピクチャ(異なるPOC)",
            "空間的スケーリングのない事例が最初にチェックされ、空間的スケーリングを可能にする事例が後に続く。空間的スケーリングは、参照ピクチャリストにかかわらず、隣接するPUの参照ピクチャと現在PUの参照ピクチャとの間でPOCが異なる場合に考慮される。左候補の全てのPUが利用できないか、または、イントラコード化されている場合には、左と上のMV候補の並列した導出を助けるために、上の動きベクトルについてスケーリングが許容される。そうでなければ、空間的スケーリングは、上の動きベクトルについて許されない。",
            "図9の例に示されるように、空間的スケーリングについて、隣接するPUの動きベクトルは、時間的スケーリングの場合と同様な方法でスケーリングされる。１つの差異は、現在PUの参照ピクチャリストおよびインデックスが入力として与えられることであり、実際のスケーリングプロセスは時間的スケーリングと同じである。",
            "１．２．３ 時間的動きベクトル候補の構築 参照ピクチャインデックスの導出とは別に、時間的マージ候補の導出のための全てのプロセスは、(図6の例に示されるように)空間的動きベクトル候補の導出のためのものと同じである。いくつかの実施形態においては、参照ピクチャインデックスが、デコーダに対して信号化される。",
            "２ ジョイント探究モデル（ＪＥＭ）におけるインター予測方法の実施例 いくつかの実施態様においては、ジョイント探究モデル（Joint Exploration Model、JEM)として知られる参照ソフトウェアを使用して、将来のビデオコーディング技術が探究される。JEMでは、いくつかのコード化ツールにおいて、サブブロックベースの予測が採用されている。アフィン予測、代替的な時間的動きベクトル予測(ATMVP)、空間的－時間的動きベクトル予測(STMVP)、双方向光学フロー(BIO)、フレームレートアップ変換(FRUC)、ローカル適応動きベクトル分解(LAMVR)、オーバーラップブロック・動き補償(OBMC)、ローカル照明補償(LIC)、および、デコーダ側動きベクトル・リファインメント(DMVR)、といったものである。",
            "２．１ サブCUベースの動きベクトル予測の実施例 四分木プラス二分木(QTBT)を有するJEMにおいて、各CUは、各予測方向について最大で1組の動きパラメータを有することができる。いくつかの実施形態においては、エンコーダにおいて２つのサブCUレベルの動きベクトル予測方法が考慮されている。大きなCUをサブCUへと分割し、そして、大きなCUに係る全てのサブCUについて動き情報を導出することによるものである。代替的な時間的動きベクトル予測(ATMVP)法により、各CUは、同一場所の参照ピクチャにおける現在CUよりも小さい複数のブロックから動き情報の複数のセットをフェッチすることができる。空間的－時間的動きベクトル予測(STMVP)法においては、時間的動きベクトル予測子および空間的隣接動きベクトルを使用することにより、サブCUの動きベクトルが再帰的に導出される。いくつかの実施形態において、そして、サブCU動き予測についてより正確な動きフィールドを保存するために、参照フレームに対する動き圧縮がディセーブルされ得る。",
            "２．１．１ 代替的な時間的動きベクトル予測(ATMVP)の実施例 ATMVP法では、現在CUより小さいブロックから動き情報の複数のセット(動きベクトルおよび参照インデックスを含む)をフェッチすることによって、時間的動きベクトル予測(TMVP)法が修正される。",
            "図10は、CU1000について一つの例示的なATMVP動き予測処理を示している。ATMVP法は、CU1000の中のサブCU1001の動きベクトルを2ステップで予測する。第１ステップは、参照ピクチャ1050内の対応するブロック1051を、時間的ベクトルを用いて識別することである。参照ピクチャ1050は、また、動きソースピクチャとしても参照される。第２ステップは、現在CU1000をサブCU1001へと分割し、そして、各サブCUに対応するブロックから、各サブCUの動きベクトル並びに参照インデックスを獲得することである。",
            "第１ステップにおいては、参照ピクチャ1050および対応するブロックが、現在CU1000の空間的隣接ブロックの動き情報によって決定される。隣接ブロックの繰り返しスキャン処理を回避するために、現在CU1000のマージ候補リスト内の第１マージ候補が使用される。第１利用可能動きベクトル並びに関連する参照ピクチャインデックスは、時間的ベクトルと、動きソースピクチャに対するインデックスであるように設定される。このように、対応するブロックが、より正確に識別され、TMVPと比較され得る。ここで、対応するブロック(ときどき同一場所のブロックと呼ばれるもの)は、常に、現在CUに対して右下または中央の位置にある。",
            "第２ステップにおいては、現在CUの座標に対して時間的ベクトルを加えることによって、サブCU1051の対応するブロックが、動きソースピクチャ1050内の時間的ベクトルにより識別される。各サブCUについて、対応するブロックの動き情報(例えば、中心サンプルをカバーする最小の動きグリッド)が、サブCUについて動き情報を導出するために使用される。対応するN×Nブロックの動き情報が識別された後で、HEVCのTMVPと同じ方法で、現在サブCUの動きベクトルおよび参照インデックスへ変換される。ここでは、動きスケーリングおよびその他のプロシージャが適用される。例えば、デコーダは、低遅延（low-delay）条件(例えば、現在ピクチャの全ての参照ピクチャのPOCが、現在ピクチャのPOCよりも小さいこと)が満たされているか否かをチェックし、そして、おそらく動きベクトルMVx(例えば、参照ピクチャリストXに対応する動きベクトル)を使用して、各サブCUについて動きベクトルMVyを予測する(例えば、Xは0または1に等しく、かつ、Yは1-Xに等しい)。",
            "２．１．２ 空間的－時間的動きベクトル予測(STMVP)の実施例 STMVP法においては、ラスタ（raster）スキャン順序に従って、サブCUの動きベクトルが再帰的に導出される。図11は、４つのサブブロックおよび隣接ブロックを有する１つのCUの例を示している。４つの4×4のサブCUであるA(1101)、B(1102)、C(1103)、およびD(1104)を含む8×8のCU1100を想定する。現在フレームで隣接する4×4ブロックは、a(1111)、b(1112)、c(1113)、d(1114)としてラベル付けされている。",
            "サブCU Aについて動き導出は、その２つの空間的隣接を識別することにより開始する。第１隣接はサブCU A1101の上のN×Nブロック(ブロックc1113)である。このブロックc(1113)が利用可能でないか、またはイントラコード化されている場合には、サブCU A(1101)の上の他のN×Nブロックがチェックされる(ブロックc1113から開始して、左から右へ)。第２隣接は、サブCU A1101の左のブロック(ブロックb1112)である。ブロックB(1112)が利用可能でないか、またはイントラコード化されている場合には、サブCU A1101の左の他のブロックがチェックされる(ブロックb1112から開始して、上から下へ)。各リストについて隣接ブロックから獲得された動き情報は、所与のリストに対する第１参照フレームに対してスケーリングされる。次に、サブブロックA1101の時間的動きベクトル予測子(TMVP)が、HEVCにおいて規定されたのと同じTMVP導出プロシージャに従うことによって導出される。ブロックD1104における同一場所のブロックの動き情報は、それに応じて、フェッチされ、そして、スケーリングされる。最後に、動き情報を取り出し、そして、スケーリングした後で、全ての利用可能な動きベクトルが、各参照リストについて別々に平均化される。平均化された動きベクトルは、現在のサブCUの動きベクトルとして割り当てられる。",
            "２．１．３ サブCU動き予測モードの信号化の実施例 いくつかの実施形態において、サブCUモードは、追加的なマージ候補としてイネーブルされ、そして、モードの信号化に必要とされる追加の構文要素は存在しない。ATMVPモードおよびSTMVPモードを表すために、各CUのマージ候補リストに対して２つの追加マージ候補が追加される。他の実施形態においては、シーケンスパラメータセットがATMVPおよびSTMVPがイネーブルされていることを示す場合に、最大で７つのマージ候補が使用され得る。追加的なマージ候補の符号化ロジック、HMにおけるマージ候補の場合と同じである。これは、ＰスライスまたはＢスライスにおける各CUについて、２つの追加的なマージ候補に対してさらに２つのRDチェックが必要とされ得ることを意味している。いくつかの実施形態、例えばJEM、において、マージインデックスの全てのビンは、コンテキストベースの適応バイナリ演算符号化（Context-based Adaptive Binary Arithmetic Coding、CABAC)によってコンテキストコード化される。他の実施形態、例えばHEVC、において、第１ビンだけがコンテキストコード化され、そして、残りのビンはコンテキストバイパス（by-pass）コード化される。",
            "２．２ VVCにおけるインター予測方法の実施例 インター予測改良のためにいくつかの新たなコード化ツールが存在している。信号化MVDのための適応動きベクトル差異分解(AMVR)、アフィン予測モード、三角予測モード(TPM)、ATMVP、一般化双予測(GBI)、双方向光学フロー(BIO)、といったものである。",
            "２．２．１ VVCにおける符号化ブロック構造の例 VVCにおいては、ピクチャを正方形ブロックまたは長方形ブロックへと分割するために、QuadTree/BinaryTree/MulitpleTree(QT/BT/TT)構造が採用されている。QT/BT/TTの他に、IフレームのVVC（VVC for I-frames）においては分離（separate）ツリー(a.k.a Dual coding tree)も、また、採用されている。別々のツリーでは、ルマ（luma）成分とクロマ（chroma）成分について、コーディングブロック構造が別々に信号化される。",
            "２．２．２ 適応動きベクトル差異分解の例 いくつかの実施形態では、スライスヘッダにおいてuse_integer_mv_flagが０に等しい場合、(動きベクトルとPUの予測動きベクトルとの間の)動きベクトル差異(MVD)は、1/4（quartet）ルマサンプルの単位で信号化される。JEMではローカル適応動きベクトル分解(LAMVR)導入されている。JEMにおいて、MVDは、1/4ルマサンプル、整数ルマサンプル、または、4ルマサンプルの単位でコード化され得る。MVD分解は、コーディングユニット(CU)レベルで制御され、そして、MVD分解フラグは、少なくとも１つの非ゼロ（non-zero）MVD成分を有する各CUについて条件付きで信号化される。",
            "少なくとも１つの非ゼロMVDコンポーネントを有するCUについて、第１フラグは、1/4ルマサンプルMV精度がCUにおいて使用されているか否かを示すために信号化されている。1/4ルマサンプルのMV精度が使用されていないことを第１フラグ(１に等しい)が示している場合には、整数ルマサンプルのMV精度または4ルマサンプルのMV精度が使用されているか否かを示すため別のフラグが信号化される。",
            "CUの第１MVD分解フラグが、ゼロであるか、または、CUに対してコード化されていない(CU内の全てのMVDがゼロであることを意味する)場合には、1/4ルマサンプルMV分解がCUに対して使用される。CUが、整数ルマサンプルのMV精度または4ルマサンプルのMV精度を使用する場合には、CUに対するAMVP候補リストにおけるMVPが、対応する精度まで丸められる（rounded）。",
            "エンコーダのいては、CUに対してどのMVD分解が使用されるべきかを決定するために、CUレベルRDチェックが使用される。つまり、CUレベルRDチェックは、各MVD分解について３回実行される。エンコーダ速度を加速するために、以下のエンコーダ方式が、JEMにおいて適用されている。",
            "－通常の1/4ルマサンプルMVD分解を用いたCUのRDチェックの最中、現在CUの動き情報(整数ルマサンプル精度)が保管される。保管された動き情報(丸めた後のもの)は、整数ルマサンプルおよび4ルマサンプルMVD分解を用いた同じCUに対するRDチェックの最中に、さらに小さな範囲の動きベクトルを精密化するための出発点として使用され、そうして、時間のかかる動き推定プロセスは３回重複されない。",
            "－4ルマサンプルMVD分解を用いたCUのRDチェックは、条件付きで呼び出される（invoked）。CUについて、整数ルマサンプルMVD分解のRDコストが1/4ルマサンプルMVD分解のものよりもはるかに大きい場合には、CUについて4ルマサンプルMVD分解のRDチェックがスキップされる。",
            "符号化プロセスが図12に示されている。最初に、1/4 pel MVが試験され、そして、RDコストが計算されて、RDCost0として示される。次いで、整数MVが試験され、そして、RDコストがRDCost1として示される。ＲＤＣｏｓｔ１＜ｔｈ＊ＲＤＣｏｓｔ０である場合(ここで、thは正の値の閾値である)の場合、4-pel MVが試験され、そうでなければ、4-pel MVはスキップされる。基本的に、整数または4-pel MVをチェックするときに、1/4 pel MVについて動き情報およびRDコスト、等は既知であり、それは、整数または4 pel MVの符号化処理を高速化するために再利用され得る。",
            "２．２．３ アフィン動き補償予測の実施例 HEVCでは、動き補償予測(MCP)に対して並進（translation）動きモデルだけが適用されている。しかしながら、カメラおよびオブジェクトは、多くの種類の動きを有し得る。例えば、ズームイン／アウト、回転、斜視移動（perspective motions）、及び／又は、他の不規則な動き、である。VVCでは、4パラメータアフィンモデルおよび6パラメータアフィンモデルを用いて、簡素化されたアフィン変換動き補償予測が適用されている。図13Aおよび図13Bに示されるように、ブロックのアフィン動きフィールドは、それぞれ、２つの制御点（control point）動きベクトル(変数a、b、eおよびfを使用する4パラメータアフィンモデルにおいて)、または、３つの制御点動きベクトル(変数a、b、c、d、eおよびfを使用する6パラメータアフィンモデルにおいて)によって、それぞれに、記述される。",
            "ブロックの動きベクトルフィールド(MVF)は、4パラメータアフィンモデルおよび6パラメータアフィンモデルを用いて、それぞれに、次の方程式で記述される。",
            "TIFF 2023052340000002.tif 26 127 式(1)",
            "TIFF 2023052340000003.tif 26 127 式(2)",
            "ここで、（ｍｖｈ ０，ｍｖｈ ０）は左上隅の制御点(CP)の動きベクトルであり、（ｍｖｈ １，ｍｖｈ １）は右上隅の制御点の動きベクトルであり、そして、（ｍｖｈ ２，ｍｖｈ ２）は左下隅の制御点の動きベクトルである。(x,y)は現在ブロックの中で左上のサンプルに対する代表点の座標を表している。CP動きベクトルは、(アフィンAMVPモードのように)信号化され、または、(アフィンマージモードのように)オンザフライ（on-the-fly）で派生される。wおよびhは現在ブロックの幅および高さである。実務上、分割は、丸め演算（rounding operation）を用いた右シフトによって実装されている。一つの実施例において、代表点は、サブブロックの中心位置であると定義される。例えば、現在ブロックの中で左上のサンプルに対するサブブロックの左上のコーナーの座標が(xs,ys)である場合に、代表点の座標は(xs+2,ys+2)であると定義される。各サブブロック(例えば、4×4)について、サブブロック全体に対する動きベクトルを導出するために、代表点が利用される。",
            "図14は、ブロック1400についてサブブロック当たりのアフィンMVFの一つの例を示しており、ここでは、モーション補償予測をさらに簡素化するために、サブブロックベースのアフィン変換予測が適用されている。各M×Nサブブロックの動きベクトルを導出するために、各サブブロックの中心サンプルの動きベクトルが式(1)および(2)に従って計算され、そして、動きベクトルのフラクション（fraction）精度まで丸められ得る(例えば、JEMでは1/16)。次いで、導出された動きベクトルを用いて各サブブロックの予測を生成するために、動き補償補間（interpolation）フィルタが適用され得る。1/16‐pelの補間フィルタがアフィンモードによって導入されている。MCPの後で、各サブブロックの高精度動きベクトルは、丸められて、通常の動きベクトルと同じ精度で保管される。",
            "２．２．４ アフィン予測の信号化に対する実施例 並進動きモデルと同様に、アフィン予測によるサイド（side）情報をシグナリングするための２つのモードが、また、存在する。それらは、AFFINE_INTERおよびAFFINE_MERGEモードである。",
            "２．２．５ AF_INTERモードの実施例 幅と高さの両方が8より大きいCUについて、AF_INTERモードが適用され得る。CUレベルにおけるアフィンフラグは、AF_INTERモードが使用されるか否か示すために、ビットストリーム内で信号化されている。",
            "このモードでは、各参照ピクチャリスト(List0またはList1)について、アフィンAMVP候補リストが、以下の順序で３つのタイプのアフィン動き予測子を用いて構築される。ここで、各候補は現在ブロックの推定（estimated）CPMVを含む。エンコーダ側で見出された最良のCPMV(図17におけるｍｖ０ ｍｖ１ ｍｖ２といったもの)と、推定CPMVとの差異が、信号化される。加えて、推定CPMVが引き出されるアフィンAMVP候補のインデックスが、さらに信号化される。 1)継承（inherited）アフィン動き予測子（predictor） チェック順序は、HEVC AMVPリスト構築における空間的MVPのものと同様である。第１に、左継承アフィン動き予測子は、アフィンコード化されて、現在ブロックと同じ参照ピクチャを有する{A1,A0}における第１ブロックから導出される。第２に、上記の継承アフィン動き予測子は、アフィンコード化されて、現在ブロックと同じ参照ピクチャを有する{B1,B0,B2}における第１ブロックから導出される。５つのブロックA1、A0、B1、B0、B2が図16に示されている。 一旦隣接ブロックがアフィンモードでコード化されることが分かると、隣接ブロックをカバーしているコーディングユニットのCPMVが、現在ブロックのCPMVの予測子を導出するために使用される。例えば、A1が非アフィンモードでコード化され、かつ、A0が4パラメータアフィンモードでコード化される場合に、左継承アフィンMV予測子はA0から導出される。この事例においては、A0をカバーしているCUのCPMVは、図18Bにおいて左上CPMVについてＭＶ０ Ｎ、および、右上のCPMVについてＭＶ１ Ｎによって示されるように、現在ブロックの推定CPMVを導出するために利用される。現在ブロックの左上(座標(x0,y0)を有する)、右上(座標(x1,y1)を有する)、および右下(座標(x2,y2)を有する)の位置についてＭＶ０ Ｃ、ＭＶ１ Ｃ、ＭＶ２ Ｃ、によって示されている。 2)構築されたアフィン動き予測子 構築されたアフィン動き予測子は、図17に示されるように、同じ参照ピクチャを有する、隣接するコード化ブロック間（inter coded blocks）から導出される制御点動きベクトル（CPMV）から構成されている。現在アフィン動きモデルが4パラメータアフィンである場合に、CPMVの数は2であり、さもなければ、現在アフィン動きモデルが6パラメータアフィンである場合に、CPMVの数は３である。左上のCPMV mv０￣は、インターコード化されて、現在ブロックと同じ参照ピクチャを有するグループ{A,B,C}における第１ブロックでのMVによって導出される。右上のCPMV mv１￣は、インターコード化されて、現在ブロックと同じ参照ピクチャを有するグループ{D,E}における第１ブロックでのMVによって導出される。左下のCPMV mv２￣は、インターコード化されて、現在ブロックと同じ参照ピクチャを有するグループ{F,G}の第１ブロックでのMVによって導出される。",
            "－現在アフィン動きモデルが4パラメータアフィンであれば、mv０￣およびmv１￣の両方が設立された場合だけ、構築されたアフィン動き予測子が候補リストの中へ挿入される。すなわち、mv０￣およびmv１￣が、現在ブロックの左上(座標(x0,y0)を有する)、右上(座標(x1,y1)を有する)位置について推定CPMVとして使用される。",
            "－現在アフィン動きモデルが6パラメータアフィンであれば、mv０￣、mv１￣、およびmv２￣の全てが設立された場合だけ、構築されたアフィン動き予測子が候補リストの中へ挿入される。すなわち、mv０￣、mv１￣、およびmv２￣が、現在ブロックの左上(座標(x0,y0)を有する)、右上(座標(x1,y1)を有する)、および、右下(座標(x2,y2)を有する)位置について推定CPMVとして使用される。 構築されたアフィン動き予測子を候補リストの中へ挿入するときに、剪定処理（pruning process）は適用されない。 3)通常の（normal）AMVP動き予測子 アフィン動き予測子の数が最大に到達するまで、以下が適用される。",
            "1)可能であれば、全てのCPMVをmv２￣に等しく設定することにより、アフィン動き予測子を導出する。",
            "2)可能であれば、全てのCPMVをmv１￣に等しく設定することにより、アフィン動き予測子を導出する。",
            "3)可能であれば、全てのCPMVをmv０￣に等しく設定することにより、アフィン動き予測子を導出する。",
            "4)可能であれば、全てのCPMVをHEVC TMVPに等しく設定することにより、アフィン動き予測子を導出する。",
            "5)全てのCPMVをゼロMVに設定することにより、アフィン動き予測子を導出する。 mvｉ￣は、構築されたアフィン動き予測子において既に導出されていることに留意する。",
            "AF_INTERモードでは、4/6パラメータアフィンモードが使用される場合、図15Aおよび15Bに示されるように、2/3の制御点が必要とされ、そして、従って、2/3のMVDは、これらの制御点に対してコード化される必要がある。既存の実装において、MVは、以下のように導出され得る。例えば、mvd0からmvd1およびmvd2を予測する。",
            "mv０＝mv０￣＋mvd０ mv１＝mv１￣＋mvd１＋mvd０ mv２＝mv２￣＋mvd２＋mvd０",
            "ここで、mvｉ￣、mvdｉ、およびmvｉは、それぞれ、図15Bに示されるように、左上ピクセル(i=0)、右上ピクセル(i=1)、または左下ピクセル(i=2)の予測動きベクトル、動きベクトル差異、および、動きベクトルである。いくつかの実施形態において、２つの動きベクトル(例えば、mvA(xA,yA)およびmvB(xB,yB))の追加は、２つの成分の別々の合計に等しい。たとえば、ｎｅｗＭＶ＝ｍｖＡ＋ｍｖＢは、newMVの２つの成分が、それぞれに、(xA+xB)および(yA+yB)に設定されていることを意味する。",
            "２．２．６ AF_MERGEモードの実施例 AF_MERGEモードでCUが適用される場合、有効な隣接再構築ブロックからアフィンモードでコード化された第１ブロックを取得する。そして、候補ブロックの選択順序は、図18Aに示されるように、左（left）、上（above）、右上（above right）、左下（left bottom）から左上（above left）まで、である(A、B、C、D、Eの順で示されている)。例えば、近隣左下ブロックが、図18BにおいてA0によって示されるように、アフィンモードでコード化されている場合、ブロックAを含む近隣CU/PUの左上隅、右上隅、および左下隅に係る制御点（CP）動きベクトルmv０ Ｎ、mv１ Ｎ、mv２ Ｎが、フェッチされる。そして、現在CU/PUにおける左上隅／右上／左下の動きベクトルmv０ Ｃ、mv１ Ｃ、mv２ Ｃ(6パラメータアフィンモデルについてだけ使用されている)が、mv０ Ｎ、mv１ Ｎ、mv２ Ｎに基づいて計算される。左上隅に配置されたサブブロック(例えば4×4ブロック)はmv0を保管し、右上隅に配置されたサブブロックは、現在ブロックがアフィンコード化されている場合に、mv1を保管する、ことが留意されるべきである。現在ブロックが6パラメータのアフィンモデルを用いてコード化されている場合、左下隅に配置されたサブブロックはmv2を保管し、さもなければ(4パラメータのアフィンモデルで)LBはmv2'を保管する。他のサブブロックは、MCに対して使用されるMVを保管する。",
            "現在CU v0およびv1のCPMVは、式のアフィン動きモデルに従って計算される。数式(1)および数式(2)に従って計算され、現在CUのMVFが生成され得る。現在CUがAF_MERGEモードを用いてコード化されているか否かを識別するために、少なくとも１つの隣接ブロックがアフィンモードにおいてコード化されている場合に、アフィンフラグが、ビットストリームで信号化され得る。",
            "いくつかの実施形態においては、アフィンマージ候補リストが、以下のステップを用いて構築され得る。",
            "１）継承アフィン候補の挿入",
            "継承（inherited）アフィン候補は、候補が、その有効な隣接アフィンコード化ブロックのアフィン動きモデルから導出されることを意味している。図19に示されるように、コモンベースにおいて、候補位置に対するスキャン順序は、A1、B1、B0、A0、そして、B2である。",
            "候補が導出された後で、同じ候補がリストに挿入されたか否かをチェックするために完全な剪定処理が実行される。同じ候補が存在する場合に、派生候補は破棄される。",
            "２）構築（constructed）アフィン候補の挿入",
            "アフィンマージ候補リストにおける候補の数がMaxNumAffineCanD(この貢献（contribution）では５に設定されている)より少ない場合に、構築アフィン候補が候補リストの中へ挿入される。構築アフィン候補と、各制御点の隣接動き情報を組み合わせることによって構築される候補を意味している。",
            "制御点に対する動き情報は、第１に、図19に示されている特定の空間的隣接および時間的隣接から導出される。CPk(k=1,2,3,4)は、k番目の制御点を表している。A0、A1、A2、B0、B1、B2、およびB3は、CPk(k=1,2,3)を予測するための空間的位置であり、Tは、CP4を予測するための時間的位置である。",
            "CP1、CP2、CP3、CP4の座標は、それぞれ、(0,0)、(W,0)、(H,0)、(W,H)である。ここで、WとHは現在ブロックの幅と高さである。",
            "各制御点の動き情報は、以下の優先順位に従って獲得される。",
            "CP1について、チェック優先度はB2→B3→A2である。利用可能な場合には、B2が使用される。そうでなければ、B2が使用できない場合には、B3が使用される。B2およびB3の両方が使用できない場合には、A2が使用される。３つの候補が全て使用できない場合には、CP1の動き情報を獲得することができない。",
            "CP2について、チェック優先度はB1→B0である。",
            "CP3について、チェック優先度はA1→A0である。",
            "CP4については、Tが使用される。",
            "第２に、アフィンマージ候補を構築するために、制御点の組み合わせが使用される。",
            "6パラメータアフィン候補を構築するためには、３つの制御点の動き情報が必要である。３つの制御点は、以下の４つの組み合わせのうち１つから選択できる（{CP1,CP2,CP4}、{CP1,CP2,CP3}、{CP2,CP3,CP4}、{CP1,CP3,CP4}）。組み合わせ{CP1,CP2,CP3}、{CP2,CP3,CP4}、{CP1,CP3,CP4}は、左上、右上、左下の制御点によって表される6パラメータ動きモデルへ変換される。",
            "4パラメータアフィン候補を構築するためには、２つの制御点の動き情報が必要である。２つの制御点は、以下の６つの組み合わせのうち１つから選択できる（{CP1,CP4}、{CP2,CP3}、{CP1,CP2}、{CP2,CP4}、{CP1,CP3}、{CP3,CP4}）。組み合わせ{CP1, CP4}、{CP2,CP3}、{CP2,CP4}、{CP1,CP3}、{CP3 CP4}は、左上および右上の制御点によって表される4パラメータ動きモデルへ変換される。",
            "構築アフィン候補の組み合わせは、次の順序のように候補リストの中へ挿入される。",
            "{CP1、CP2、CP3}、{CP1、CP2、CP4}、{CP1、CP3、CP4}、{CP2、CP3、CP4}、{CP1、CP2}、{CP1、CP3}、{CP1、CP3}、{CP2、CP3}、{CP1、CP4}、{CP2、CP4}、{CP3、CP4}}",
            "組み合わせの参照リストX（Xは0または1である）については、制御点における最も高い使用率を有する参照インデックスが、リストXの参照インデックスとして選択され、そして、異なる参照ピクチャに対する動きベクトルポイントがスケーリングされる（scaled）。",
            "候補が導出された後で、同じ候補がリストに挿入されたか否かをチェックするために完全な剪定処理が実行される。同じ候補が存在する場合に、派生候補は破棄される。",
            "３）動きベクトルゼロのパディング",
            "アフィンマージ候補リストにおける候補の数が５未満の場合には、リストが満杯になるまで、ゼロ参照インデックスを伴うゼロ動きベクトルが候補リストの中へ挿入される。",
            "いくつかの実施形態において、サブブロックマージ候補リストについて、4パラメータマージ候補は、(0,0)に設定されたMV、および、リスト0から単一予測（Ｐスライスについて)および双予測(Ｂスライスについて)に設定された予測方向を伴う。",
            "２．３ イントラブロックコピーの実施例 HEVCスクリーンコンテンツコード化拡張(SCC)においては、現在ピクチャ参照(CPR)としても呼ばれる、イントラブロックコピー(IBC、またはイントラピクチャブロック補償)が採用された。このツールは、同一ピクチャの中でテキストの繰り返しパターンおよびグラフィックスが豊富なコンテンツが頻繁に発生するという点で、スクリーンコンテンツビデオのコーディングについて非常に効率的である。予測子として同等または類似のパターンを伴う以前に再構成されたブロックを有することは、予測誤差を効果的に低減し、そして、従って、コード化効率を改善することができる。イントラブロック補償の一つの例が図20に示されている。",
            "HEVC SCCにおけるCRPの設計と同様に、VVCにおいて、IBCモードの使用は、シーケンスおよびピクチャレベルの両方において信号化される。IBCモードがシーケンスパラメータセット(SPS)においてイネーブルされると、それはピクチャレベルでイネーブルにすることができる。IBCモードがピクチャレベルにおいてイネーブルされると、現在の再構成されたピクチャが参照ピクチャとして扱われる。従って、IBCモードの使用を信号化するために、既存のVVCインターモードの上にブロックレベルの構文変更（syntax change）は必要とされない。",
            "CPRの特徴のいくつかは、以下のものを含む。",
            "・それは通常の（normal）インターモードとして扱われる。従って、マージモードおよびスキップモードは、また、IBCモードについても使用可能である。マージ候補リスト構築は、IBCモードまたはHEVCインターモードのいずれかでコード化された隣接位置からのマージ候補を含んでおり、統一されている。選択されたマージインデックスに応じて、マージまたはスキップモード下の現在ブロックは、IBCモードでコード化された隣接、または、そうでなければ、参照ピクチャとして異なるピクチャを用いて通常のインターモードでコード化されたもの、のいずれかへとマージすることができる。",
            "・IBCモードのためのブロックベクトル予測およびコーディングスキームは、HEVCインターモードにおける動きベクトル予測およびコーディングのために使用されるスキームを再利用する。",
            "・ブロックベクトルとしても参照される、IBCモードの動きベクトルは、整数ペル（integer-pel）精度で符号化されるが、補間および非ブロック化段階は1/4ペル精度が要求されるので、復号化の後に1/16ペル精度でメモリに保管される。IBCモードのための動きベクトル予測において使用される場合、保管されたベクトル予測子は４だけ右シフトされる。",
            "・検索範囲：それは現在CTUの中にあるように制限されている。",
            "・アフィンモード／三角モード／GBI重み付け予測がイネーブルされている場合には、CPRが許可されない。",
            "２．３．１ CPRとの調和 PCT/CN2018/089920においては、CPR(a.k.a IBC)といくつかの新たなコード化ツールを調和させるためにいくつかの方法が提案されている。",
            "２．４ VVCにおけるマージリストの設計例 VVCにおいてサポートされている３つの異なるマージリスト構築プロセスが存在している。",
            "(1)サブブロックマージ候補リスト：それは、ATMVPおよびアフィンマージ候補を含んでいる。アフィンモードおよびATMVPモードの両方について、１つのマージリスト構築プロセスが共有される。ここでは、ATMVPおよびアフィンマージ候補が、順番に追加され得る。サブブロックマージリストのサイズはスライスヘッダにおいて信号化され、そして、最大値は５である。",
            "(2)単一予測（uni-Prediction）TPMマージリスト：三角予測モードについて、２つのパーティションに対する１つのマージリスト構築プロセスは、２つのパーティションが独自のマージ候補インデックスを選択できても、共有される。このマージリストを構成するときに、空間的隣接ブロックおよびブロックの２つの時間的ブロックがチェックされる。空間的近隣および時間的ブロックから導出された動き情報は、IDFにおいてレギュラー（regular）動き候補と呼ばれる。これらのレギュラー動き候補は、複数のTPM候補を導出するためにさらに利用される。変換は、２つのパーティションが独自の予測ブロックを生成するために異なる動きベクトルを使用することができても、ブロックレベル全体で実行されることに注意すること。いくつかの実施形態において、単一予測TPMマージリストのサイズは、５に固定されている。",
            "(3)レギュラーマージリスト：残りのコーディングブロックについては、１つのマージリスト構築プロセスが共有される。ここで、空間的／時間的／HMVP、対での（pairwise）結合双予測マージ候補およびゼロ動き候補が、順番に挿入され得る。レギュラーマージリストサイズは、スライスヘッダにおいて信号化されており、そして、最大値は６である。",
            "サブブロックマージ候補リスト",
            "全てのサブブロック関連モーション候補は、非サブブロックマージ候補に対するレギュラーマージリストに加えて、別個のマージリスト内に置かれることが示唆されている。",
            "サブブロック関連モーション候補は、「サブブロックマージ候補リスト（“sub-block merge candidate list”）」として名付けられた別のマージリスト内に置かれている。",
            "一つの例において、サブブロックマージ候補リストは、アフィンマージ候補、およびATMVP候補、及び／又はサブブロックベースのSTMVP候補を含んでいる。",
            "別の例において、通常のマージリストにおけるATMVPマージ候補は、アフィンマージリストの第１位置へ移動される。新たなリスト内の全てのマージ候補(すなわち、サブブロックベースのマージ候補リスト)が、サブブロックコーディングツールに基づいているようにする。",
            "さらに別の例において、サブブロックマージ候補リスト(a.k.a アフィンマージ候補リスト)として知られる、特別なマージ候補リストが、レギュラーマージ候補リストの他に追加される。サブブロックマージ候補リストは、以下の順番において、候補で埋められている。",
            "(a)ATMVP候補(利用可能または利用不能であり得る)",
            "(b)継承アフィン候補",
            "(c)構築アフィン候補",
            "(d)ゼロMV 4パラメータアフィンモデルとしてパディング",
            "サブブロックマージ候補リストにおける候補の最大数(MLとして示される)は、以下のように導出される。",
            "(1)ATMVP使用フラグ(例えば、\"sps_stmvp_enabled_flag\"として名付けられ得るフラグ)がオンである(１に等しい)が、アフィン使用フラグ(例えば、\"sps_affine_enabled_flag\"として名付けられ得るフラグ)がオフである(０に等しい)場合には、MLが、１に等しく設定される。",
            "(2)ATMVP使用フラグがオフであり(０に等しい)、かつ、アフィン使用フラグがオフである(０に等しい)場合には、MLが、０に等しく設定される。この場合、サブブロックマージ候補リストは使用されない。",
            "(3)そうでなければ(アフィン使用フラグがオンであり(１に等しい)、ATMVP使用フラグがオンまたはオフである)、MLが、エンコーダからデコーダへ信号化される。有効なMLは、０≦ML≦５である。",
            "サブブロックマージ候補リストを作成する場合は、第１にATMVP候補がチェックされる。以下の条件のうちいずれか１つが真である場合に、ATMVP候補はスキップされ、そして、サブブロックマージ候補リストの中へ置かれない。",
            "(1)ATMVP使用フラグがオフである",
            "(2)任意のTMVP使用フラグ(例えば、スライスレベルで信号化されるときに\"slice_temporal_mvp_enabled_flag\"として名付けられ得るフラグ)がオフである",
            "(3)参照リスト０において参照インデックス０を有する参照ピクチャは、現在ピクチャと同一である(それはCPRである)。",
            "上記の例におけるATMVPは、JEMよりもずっと単純である。ATMVPマージ候補が生成されるときに、以下の処理が適用される。",
            "(a)図2に示されるような順番で隣接するブロックA1、B1、B0、A0をチェックして、CPRコード化ブロックではないが、ブロックXとして示されている、第１インターコード化ブロックを見つける。",
            "(b)TMV=(0,0)を初期化する。ブロックXのMV(MVnとして示されている)が存在する場合、(スライスヘッダにおいて信号化されるように)配置された参照ピクチャを参照して、TMVはMVnに等しく設定される。",
            "(c)現在ブロックの中心点が(x0,y0)であると仮定して、(x0,y0)の対応する位置を、配置された（collocated）ピクチャ内のM=(x0+MV*x,y0+MV*y)として突き止める。MをカバーするブロックZを見つける。",
            "(i)Zがイントラコード化されている場合、ATMVPは利用可能ではない。",
            "(ii)Zがインターコード化されている場合、ブロックZの２つのリストについてMVZ_0およびMVZ_1は、MVdefault0、MVdefault1として(Reflist0 index0)および(Reflist1 index1)へスケーリングされ、そして、保管される。",
            "(d)各8×8サブブロックについて、その中心点が(x0S,y0S)であると仮定して、(x0S,y0S)の対応する位置を、配置されたピクチャ内のMS=(x0S+MV*x,y0S+MV*y)として突き止める。MSをカバーするブロックZSを見つける。",
            "(i)ZSがイントラコード化されている場合、MVdefault0、MVdefault1がサブブロックに対して割り当てられる。",
            "(ii)ZSがインターコード化されている場合、ブロックZSの２つのリストについてMVZS_0およびMVZS_1は、(Reflist0 index0)および(Reflist1 index0)へスケーリングされ、そして、サブブロックに対して割り当てられる。",
            "ATMVPにおけるMVクリッピングおよびマスキング: 配置されたピクチャ内のMまたはMSといった、対応する位置を突き止める場合には、事前に定義された領域の内側であるようにクリップされる。CTUサイズは、S×Sであり、本実施例においては、S=128である。配置されたCTUの左上の位置が(xCTU,yCTU)であると仮定すると、(xN,yN)における対応する位置MまたはMSは、有効領域xCTU≦xN＜xCTU+S+4；yCTU≦yN＜yCTU+Sへとリップされる。図21は、有効領域の一つの例を示している。",
            "クリッピングの他に、(xN,yN)は、また、xN=xN&MASK、yN=yN&MASKとしてもマスクされる。ここで、MASKは、～(2N-1)に等しい整数であり、かつ、N=3であり、下位3ビットが０に設定する。そうして、xNおよびyNは、8の倍数であることを要する。(「～」はビット単位（bitwise）の補数演算子（complement operator）を表している。)",
            "レギュラーマージリスト",
            "マージリスト設計とは異なり、VVCにおいては、履歴ベースの動きベクトル予測(HMVP)法が採用されている。いくつかの実施形態において、結合双予測マージ候補は、対での双予測マージ候補によって置き換えられている。",
            "HMVP",
            "HMVPでは、以前にコード化された動き情報が保管される。以前にコード化されたブロックの動き情報は、HMVP候補として定義される。複数のHMVP候補は、HMVPテーブルとして名付けられた、テーブル内に保管され、そして、このテーブルは、符号化／復号化プロセスの最中にオンザフライで保持されている。HMVPテーブルは、符号化／復号化の新たなスライスを開始するときに、空（empty）にされる。インターコード化ブロックが存在するときはいつでも、関連する動き情報が、新たなHMVP候補としてテーブルの最後のエントリーに追加される。全体的なコーディングフローが図22に示されている。",
            "HMVP候補は、AMVPおよびマージ候補リスト構築プロセスの両方において使用され得る。図23は、修正されたマージ候補リスト構築プロセスを示している(グレーにハイライトされている)。TMVP候補の挿入後にマージ候補リストが満杯でない場合は、マージ候補リストを満杯にするために、HMVPテーブル内に保管されたHMVP候補が使用され得る。１ブロックが、たいてい、動き情報に関して最も近い隣接ブロックと高い相関を有することを考慮して、テーブル内のHMVP候補が、インデックスの降順に挿入されている。テーブル内の最後のエントリーは最初にリストに追加され、一方で、最初のエントリーは最後に追加される。同様に、冗長性除去がHMVP候補について適用される。一旦、利用可能なマージ候補の総数が、信号化されることが許されるマージ候補の最大数に到達すると、マージ候補リスト構築プロセスは終了される。",
            "２．５ 一般化された双予測(GBi)改善の実施例 一つの実施例において提案された一般化された双予測改善(Generalized Bi-prediction improvement、GBi)が提供される。",
            "一つの例においてGBiが提案された。GBiについて利得－複雑性（gain-complexity）のトレードオフを改善した改良された実施形態が提供され、それは、双予測モードにおいてL0およびL1からの不均等な重み付けを予測子に適用する。インター予測モードでは、均等重み付けペア（equal weighted pair）(1/2,1/2)を含む複数の重み付けペアがレート歪最適化(rate-distortion optimization、RDO)に基づいて評価され、そして、選択された重み付けペアのGBiインデックスがデコーダに対して信号化される。マージモードでは、GBiインデックスが、隣接するCUから継承される。本実施形態においては、双予測モードにおける予測子生成が、以下の式で示されている。",
            "ＰＧＢｉ＝（ｗ０＊ＰＬ０＋ｗ１＊ＰＬ１＋ＲｏｕｎｄｉｎｇＯｆｆｓｅｔＧＢｉ）＞＞ＳｈｉｔＮｕｍＧＢｉ",
            "ここで、PGBiはGBiの最終予測子である。w0およびw1は選択されたGBi重み付けペアあり、そして、list0(L0)およびlist(L1)の予測子に対して、それぞれに、適用されている。GBiにおける最終予測子を正規化するために、RoundingOffsetGBiおよびshiftNumGBiが使用されている。サポートされるw1重み付けセットは{-1/4,3/8,1/2,5/8,5/4}であり、５つの重み付けが１つの均等重み付けペアおよび４つの不均等重み付けペアに対応している。混合利得（blending gain）、すなわちw1およびw0の合計は1.0に固定されている。従って、対応するw0重み付けセットは{5/4、5/8、1/2、3/8、-1/4}である。重み付けペアの選択は、CUレベルである。",
            "非低遅延（non-low delay）ピクチャについて、重み付けセットサイズは５から３へ削減される。ここで、w1重み付けセットは{3/8,1/2,5/8}であり、そして、w0重み付けセットは{5/8,1/2,3/8}である。非低遅延ピクチャのための重み付けセットのサイズ削減は、この貢献においてGBiおよび全てのGBi試験に対して適用されている。",
            "一つの実施形態においては、GBi性能をさらに改善するために、結合ソリューションが提案される。具体的には、以下の修正が、実施形態における既存のGBi設計の上に適用される。",
            "GBiエンコーダのバグ修正",
            "GBi符号化時間を短縮するために、現在のエンコーダ設計において、エンコーダは、4/8に等しいGBi重み付けから推定された単一予測動きベクトルを保管し、そして、他のGBi重み付けの単一予測サーチのためにそれらを再利用する。この高速符号化方法が、並進動きモデルおよびアフィン動きモデルの両方に対して適用されている。一つの例においては、6パラメータアフィンモデルが、4パラメータアフィンモデルと共に採用された。エンコーダは、GBi重み付けが4/8に等しいときに単一予測アフィンMVを保管する場合に、4パラメータアフィンモデルと6パラメータアフィンモデルを区別しない。その結果、4パラメータアフィンMVは、GBi重み付け4/8で符号化した後で、6パラメータアフィンMVによって上書きされ得る。保管された6パラメータアフィンMVは、他のGBi重み付けに対する4パラメータアフィンMEについて使用されてよく、または、保管された4パラメータアフィンMVは、6パラメータアフィンMEについて使用されてよい。提案されたGBiエンコーダのバグ修正は、4-パラマータおよび6-パラメータアフィンMVのストレージを分離することである。エンコーダは、GBi重み付けが4/8に等しい場合、アフィンモデルタイプに基づいて、それらのアフィンMVを保管し、そして、他のGBi重み付けについて、アフィンモデルタイプに基づいて、対応するアフィンMVを再利用する。",
            "GBiに対するCUサイズの制約",
            "この方法では、小さなCUに対してGBiがディセーブルされている。インター予測モードでは、双予測が使用され、かつ、CU領域が128ルマサンプルより小さい場合に、GBiは、シグナリングなしでディセーブルされる。",
            "GBiとのマージモード",
            "マージモードでは、GBiインデックスは信号化されない。代わりに、マージ先の隣接するブロックから継承される。TMVP候補が選択されると、このブロックにおいてGBiがターンオフ（turned off）される。",
            "GBiを用いたアフィン予測",
            "現在ブロックがアフィン予測を用いてコード化されている場合に、GBiが使用され得る。アフィンインターモードについては、GBiインデックスが信号化される。アフィンマージモードについて、GBiインデックスはマージ先の隣接ブロックから継承される。構築されたアフィンモデルが選択されると、このブロックにおいてGBiがターンオフされる。",
            "２．６ インター－イントラ予測(IIP)モードの実施例 インター－イントラ予測（inter-intra prediction）モードでは、マルチ仮説（multi-hypothesis）予測が、１つのイントラ予測および１つのマージインデックス予測を結合する。そうしたブロックは、特別なインターコード化（inter-coded）ブロックとして扱われる。マージCUにおいては、フラグが真の場合に、イントラ候補リストからイントラモードを選択するために、マージモードについて１つのフラグが信号化される。ルマ成分（luma component）について、イントラ候補リストは、DC、プラナー（planar）、水平（horizontal）、および垂直（vertical）モードを含む４つのイントラ予測モードから導出され、そして、イントラ候補リストのサイズは、ブロックの形状に応じて３または４であり得る。CU幅がCU高さの2倍より大きい場合には、水平モードがイントラモードのリストから除かれ、そして、CU高さがCU幅の2倍より大きい場合には、垂直モードがイントラモードのリストから除外される。イントラモードインデックスによって選択された１つのイントラ予測モード、および、マージインデックスによって選択された１つのマージインデックス予測が、加重平均を使用して結合される。クロマ成分（chroma component）については、DMが、余分なシグナリングなしで 常に適用される。",
            "予測を結合するための重み付けは、以下のように記述される。DCまたはプラナーモードが選択された場合、または、CB幅または高さが４より小さい場合には、均等重み付けが適用される。CB幅および高さが４以上であるそれらのCBについては、水平/垂直モードが選択された場合、１つのCBが最初に４つの均等面積領域（equal-area region）へと垂直／水平に分割される。各重み付けセット、(w_intra,w_inter)として示されるものが、対応する領域に適用される。ここで、iは1から4まで、そして、(w_intrA1,w_inter1)=(6,2)、(w_intra2,w_inter2)=(5,3)、(w_intra3,w_inter3)=(3,5)、および、(w_intra4,w_inter4)=(2,6)である。(w_intra1,w_inter1)は参照サンプルに最も近い領域に対するものであり、そして、(w_intra4,w_inter4)は参照サンプルから最も離れた領域に対するものである。次いで、結合予測が、２つの重み付き予測および右シフト３ビットを合計することによって計算され得る。さらに、予測子のイントラ仮説に対するイントラ予測モードが、次に続く隣接CUの参照のために保存され得る。",
            "一つの実施例における詳細設計 １．inter_intra_flag(１つの新たなコンテキスト)は、全ての条件が満足された場合に信号化される。",
            "ａ．マージするがスキップしない。",
            "ｂ．アフィンではない。",
            "ｃ．MMVDではない。",
            "ｄ．W*H<64、かつ、W!=128、かつ、H!=128(ここでは2*8クロマのイントラ予測を有し得ることを意味する) ２．インター－イントラ予測が、三角予測において適用され得る。",
            "３．Y,Cb,Crに対してインター－イントラ予測が適用される。",
            "４．inter_intra_flagがオンの場合、イントラ予測モード(IPM)が信号化される。IPMは{DC,Planar,Ver,Hor}のうちの１つであることを要する。",
            "ａ．３つのMPMが包含される。",
            "ｂ．W>2*HまたはH>2*Wの場合、IPMは３つのMPMのうちの１つであることを要し、かつ、MPM-flagは信号化されない。そうでなければ、MPM-flagが信号化される(１つの新たなコンテキスト、なぜイントラと同じコンテキストを共有しないのか？)。",
            "ｉ．MPM_flagがオンの場合、選択されたMPMを信号化する。0,10,11は、３つのMPM(バイパス)を表している。",
            "ｉｉ．そうでなければ、MPMリストにない{DC,Planar,Ver,Hor}における１つを、IPMとして見つける。",
            "ｃ．MPMリストの構成(イントラMPMリストとは異なる) ｉ．LeftIPM=AboveIPM=DCと設定する。",
            "ｉｉ．左隣接ブロック(A2)がイントラコード化またはインター－イントラコード化されている場合に、leftIPMを左隣接ブロックのIPMに設定する。",
            "ｉｉｉ．上隣接ブロック(B3)がイントラコード化またはインター－イントラコード化されている場合に、aboveIPMを上隣接ブロックのIPMに設定する。",
            "ｉｖ．leftIPM=(leftIPM>DC_IDX)?((leftIPM≦DIA_IDX)?HOR_IDX:VER_IDX):leftIPM; ｖ．IPM=(IPM>DC_IDX)?((aboveIPM≦DIA_IDX)?HOR_IDX:VER_IDX):aboveIPM; (ワイドアングルモードはどうですか?) ｖｉ．leftIPM==aboveIPMである場合 1.LeftIPMがDCまたはプラナーでない場合 ａ．MPM[0]=leftIPM、MPM[1]=Planar、MPM[2]=DC 2.それ以外の場合 ａ．MPM[0]=DC、MPM[1]=Planar、MPM[2]=Ver ｖｉｉ．それ以外の場合 1.MPM[0]=leftIPM、MPM[1]=aboveIPM 2.leftIPMおよびaboveIPMがプラナーでない場合、MPM[2]=Planar 3.そうでなければ、MPM[2]=(leftIPM+aboveIPM)<2?Ver:DC ｖｉｉｉ．W>2×Hである場合 1.MPM[x]==Horである場合、MPMリストではなく{DC,Planar,Ver,Hor}においてModeXをFindする、MPM[x]=ModeXを設定する。",
            "ｉｘ．H>2*Wである場合 1.MPM[x]==Verである場合、MPMリストではなく{DC,Planar,Ver,Hor}においてModeXをFindする、MPM[x]=ModeXを設定する。",
            "５．インター－イントラ予測によって使用されるIPMは、イントラコード化ブロックのIPMを予測するために使用できないことに注意すべきである。",
            "ａ．内部符号化ブロックを内部符号化ブロックとして処理する内部符号化ブロック ６．隣接サンプルのフィルタリング：イントラ予測として： ａ．DC/VER/HORについてフィルタリングしない。",
            "ｂ．W*H>32の場合、プラナーについてフィルタリングする。",
            "ｃ．PDPCが保持される。",
            "７．重み付け合計方法 ａ．P(x,y)=Clip((W0(x,y)*P_Intra(x,y)+W1(x,y)*P_Inter(x,y))>>3) ８．重み付け値(改善または簡略化され得る) ａ．mode==DC/Planarの場合、||W<4||H<4:W0=W1=4; ｂ．mode==HORの場合: ｉ．x<W/4の場合、W0=6、W1=2; ｉｉ．W/4≦x<W/2の場合、W0=5、W1=3; ｉｉｉ．W/2≦x<3*W/4の場合、W0=3、W1=5; ｉｖ．x≧3×W/4の場合、W0=2、W1=6; ｃ．mode==VERの場合: ｉ．y<H/4の場合、W0=6、W1=2; ｉｉ．H/4≦y<H/2の場合、W0=5、W1=3; ｉｉｉ．H/2≦y<3×H/4の場合、W0=3、W1=5; ｉｖ．y≧3×H/4の場合、W0=2、W1=6",
            "２．７ 究極動きベクトル表現(UMVE)の実施例 いくつかの実施形態において、究極（ultimate）動きベクトル表現(UMVE)が提示される。UMVEは、提案される動きベクトル表現方法を用いて、スキップモードまたはマージモードのいずれかについて使用される。",
            "UMVEは、VVCにおけるレギュラー（regular）マージ候補リスト内に含まれるものと同じマージ候補を再利用する。マージ候補の中で、ベース候補（base candidate）を選択することができ、そして、提案される動きベクトル表現方法によってさらに拡張されている。",
            "UMVEは、新たな動きベクトル差異(MVD)表現方法を提供する。そこでは、MVDを表現するために、開始点、動きの大きさ、および、動きの方向が使用される。",
            "この提案される技法は、マージ候補リストをそのまま使用する。しかし、デフォルトマージタイプ(MRG_TYPE_DEFAULT_N)の候補だけが、UMVEの拡張のために考慮される。",
            "ベース候補インデックスは、開始点を定義する。ベース候補インデックスは、リスト内の候補の中で最良の候補を以下のように示している。",
            "TIFF 2023052340000004.tif 20 147 表１：ベース候補IDX",
            "ベース候補の数が１に等しい場合、ベース候補IDXは信号化されない。",
            "距離インデックスは、動きの大きさ情報である。距離インデックスは、開始点情報から事前に定義された距離を示す。事前に定義された距離は、以下のとおりである。",
            "TIFF 2023052340000005.tif 23 163 表２：距離IDX",
            "方向インデックスは、開始点に対するMVDの方向を表している。方向インデックスは、以下に示すように４方向を表すことができる。",
            "TIFF 2023052340000006.tif 24 155 表３：方向IDX",
            "UMVEフラグは、スキップフラグまたはマージフラグを送信した直後に信号化される。スキップフラグまたはマージフラグが真（true）である場合に、UMVEフラグが構文解析（parsed）される。UMVEフラグが１に等しい場合、UMVE構文が構文解析される。しかし、１でない場合、AFFINEフラグが構文解析される。AFFINEフラグが１に等しい場合には、AFFINEモードであるが、１でない場合、スキップ／マージインデックスが、スキップ／マージモードについて構文解析される。",
            "UMVE候補による追加のライン（line）バッファは必要とされない。ベース候補として、ソフトウェアのスキップ／マージ候補が直接的に使用されるからである。入力UMVEインデックスを使用して、動き補償の直前に、MVの補足（supplement）補正が決定される。このため、長いラインバッファを保持する必要がない。",
            "現在の一般的なテスト条件においては、マージ候補リスト内の第１マージ候補または第２マージ候補のいずれかが、ベース候補として選択され得る。",
            "UMVEは、MVDを用いたマージ（Merge with MVD、MMVD)として知られている。",
            "３ 既存の実装の欠点 既存の実装(例えば、現在のVVC設計)において、CPRは、これらの問題を有している。",
            "(1)CPRとアフィンとの間の相互作用（interaction）が未だに不明である。(例えば、CPRコード化ブロックについて、サブブロックマージリストまたはレギュラーマージリストへマージ候補が挿入され得る。)",
            "(2)CPRと一般的な双予測との間の相互作用が未だに不明である。(例えば、CPRコード化ブロックについては、常に固定された半々（half-half）の重み付けを使用しており、従って、重み付けインデックスを信号化する必要はない。)",
            "(3)CPRとMMVD(a.k.a. UMVE)との間の相互作用が未だに不明である。",
            "(4)CPRとインター－イントラ予測との間の相互作用が未だに不明である。",
            "(5)ATMVPとCPRとの間の相互作用",
            "(6)２つ(別々の)コード化ツリーを用いたCPRをどのように適用するかは、未だに不明である。",
            "４ CPRのための動きベクトル導出およびシグナリングの方法の実施例 ここで開示される技術の実施形態は、既存の実装の欠点を克服し、それによって、より高いコード化効率を有するビデオコーディングを提供している。開示される技術に基づいて、ビデオおよび画像コード化を参照する現在ピクチャに対する動きベクトル導出およびシグナリングの使用は、現存および将来の両方のビデオコーディング標準を向上させ得るものであり、種々の実装のために説明される以下の実施例において解明される。以下に提供される、開示される技術の例は、一般的な概念を説明するものであり、そして、限定的なものとして解釈されることを意図するものではない。例においては、明示的に反対に示されない限り、これらの実施例において説明された種々の特徴が組み合わされ得る。「ブロックまたは候補がCPRを使用する（“a block or a candidate uses CPR”）」ということは、以下のことを意味し得ることが留意されるべきである。",
            "(i)ブロックまたは候補によって使用される参照ピクチャは全てCPRである。または、",
            "(ii)ブロックまたは候補によって使用される少なくとも１つの参照ピクチャはCPRである。",
            "実施例１． アフィン動き補償が使用される場合、CPRを使用することは許されない。",
            "(a)一つの例において、適合（conformance）ビットストリームは、単一ブロックにおいてCPRおよびアフィン動き補償を同時に使用することはできない。",
            "(b)一つの例において、構文解析プロセスにおいては、ブロックレベルのアフィン・イネーブル／ディセーブル・フラグが、最初にシグナリングされ得る。１つのブロックがアフィンモードでコード化される場合、現在ブロックの参照ピクチャインデックスが、現在ピクチャが関連付けられているものと等しいか否かを信号化する必要はない。",
            "(c)代替的に、参照ピクチャインデックスは、ブロックレベルのアフィン・イネーブル／ディセーブル・フラグの前に信号化されてよい。ブロックがCPRを使用する場合、アフィンフラグのシグナリングは、常にスキップされる。",
            "(d)代替的に、参照ピクチャインデックスは、ブロックレベルのアフィン・イネーブル／ディセーブル・フラグの前に信号化されてよい。ブロックが双予測を用いてコード化され、かつ、１つの参照ピクチャだけが現在の参照ピクチャである場合、アフィンフラグは、未だに信号化され得る。",
            "(i)一つの例においては、さらに、そうしたブロックに対して整数（integer）動きベクトルが使用されることが必要とされる。",
            "実施例２． ブロックは、CPRを使用する隣接ブロックからアフィンモデルを継承することができない。",
            "(a)一つの例において、CPRを使用する隣接ブロックは、サブブロックマージ候補リストにおいてアフィンマージ候補を導出するために使用することができない。",
            "(i)一つの例において、CPRを使用する隣接ブロックは、サブブロックマージ候補リスト構築プロセスにおいて利用できないものとして扱われる。",
            "(b)一つの例において、CPRを使用する隣接ブロックは、アフィンAMVPリストにおけるアフィンAMVP候補を導出するために使用することができない。",
            "(i)一つの例において、CPRを使用する隣接ブロックは、アフィンAMVP候補リスト構築プロセスにおいて利用できないものとして扱われる。",
            "実施例３． ブロックがCPRを使用する隣接ブロックからアフィンモデルを継承できるか否かは、参照リストに依存している。",
            "(a)一つの例として、隣接ブロックが双予測を適用すると仮定する。参照リストX(Xは０または１であり得る)の参照ピクチャが現在ピクチャであり、かつ、参照リスト(1-X)における参照ピクチャは現在ピクチャではない。",
            "(i)参照リストXを参照する隣接ブロックの動き情報は、サブブロックマージ候補リスト内のアフィンマージ候補を導出するために使用することはできない。",
            "(1)一つの例において、参照リスト(1-X)を参照する隣接ブロックの動き情報は、サブブロックマージ候補リスト内のアフィンマージ候補を導出するために使用され得る。",
            "(ii)参照リストXを参照する隣接ブロックの動き情報は、アフィンAMVPリスト内のアフィンAMVP候補を導出するために使用することはできない。",
            "(1)例えば、参照リストXを参照する隣接ブロックの動き情報は、参照リストXに対するアフィンAMVPリスト内のアフィンAMVP候補を導出するために使用することはできない。",
            "(iii)参照リスト(1-X)を参照する隣接ブロックの動き情報は、アフィンAMVPリスト内のアフィンAMVP候補を導出するために使用され得る。",
            "(1)例えば、参照リスト(1-X)を参照する隣接ブロックの動き情報は、参照リスト(1-X)に対するアフィンAMVPリスト内のアフィンAMVP候補を導出するために使用され得る。",
            "実施例４． ブロック内でGBiが適用されている場合(GBi重み付け値が２つの参照ピクチャにおいて等しくない場合)、CPRを使用することは許されない。",
            "(a)一つの例において、適合ビットストリームは、単一ブロックでCPRおよびGBiを同時に使用することはできない。",
            "(b)一つの例において、ブロック内でCPRが使用される場合、GBi重み付けインデックスは信号化されず、そして、０であると推定される(重み付け値は２つの参照ピクチャにおいて等しい)。",
            "(c)一つの例において、ブロックにおいてGBi内で不均等な重み付けが適用される(GBi重み付け値が２つの参照ピクチャにおいて等しくない)場合、CPR指示は信号化されず、かつ、０であると推定される(CPRは使用されない)。",
            "実施例５． ブロックにおいてMMVDが適用される場合、CPRを使用することは許されない。",
            "(a)一つの例において、適合ビットストリームは、単一ブロックにおいてCPRおよびMMVDを同時に使用できない。",
            "(b)一つの例において、ブロック内でCPRが使用される場合、MMVDフラグは信号化されず、かつ、０であると推定される(重み付け値は、２つの参照ピクチャにおいて等しい)。",
            "(c)一つの例において、ブロック内でMMVDが適用される場合、CPR指示は信号化されず、かつ、０であると推定される(CPRは使用されない)。",
            "実施例６． ブロック内でMMVDが適用される場合、CPRを使用することが許される。",
            "(a)一つの例において、ベースMV候補が現在ピクチャを参照する少なくとも１つの参照ピクチャを有する場合である。",
            "(i)一つの例において、MMVDは、現在ピクチャを参照するMVに基づいており、現在ピクチャを参照しないMV(存在する場合)を省略している。",
            "(ii)一つの例において、MMVDによって信号化される距離は、整数だけであり得る。",
            "(iii)一つの例において、MMVDは単一予測である。",
            "(b)一つの例において、ベースMV候補が、現在ピクチャを参照しない少なくとも１つの参照ピクチャを有する場合である。",
            "(i)一つの例において、MMVDは、現在ピクチャを参照しないMVに基づいており、現在ピクチャを参照するMV(存在する場合)を省略している。",
            "実施例７． ブロック内でインター－イントラ予測が適用される場合、CPRを使用することは許されない。",
            "(a)一つの例において、適合ビットストリームは、単一ブロックにおいてCPRおよびイントラ予測を同時に使用することはできない。",
            "(b)一つの例において、ブロック内でCPRが使用される場合、インター－イントラ予測フラグは信号化されず、かつ、０であると推定される。",
            "(c)一つの例として、ブロック内でインター－イントラ予測が適用される場合、CPR指示は信号化されず、かつ、０であると推定される(CPRは使用されない)。",
            "実施例８． ブロック内でインター－イントラ予測が適用される場合、CPRを使用することが許される。",
            "(a)一つの例において、インター－イントラ予測を行うためのマージ候補が、現在ピクチャを参照する少なくとも１つの参照ピクチャを有する場合である。",
            "(i)一つの例において、インター－イントラ予測は、現在ピクチャを参照するMVに基づいており、現在ピクチャを参照しないMV(存在する場合)を省略している。",
            "(ii)一つの例において、インター－イントラ予測のイントラ予測部分は、次のように変更され得る。",
            "(1)境界フィルタリングが行われない。",
            "(2)位置依存予測組み合わせ(Position Dependent Prediction Combination、PDPC)が行われない。",
            "(3)これらの特定のモードだけが許可される。",
            "・MPM",
            "・DC",
            "・垂直",
            "・水平",
            "(iii)一つの例において、インター－イントラ予測のインター予測部分は、単一予測される。",
            "(b)一つの例において、インター－イントラ予測を行うためのマージ候補が、現在ピクチャを参照しない少なくとも１つの参照ピクチャを有する場合である。",
            "(i)一つの例において、インター－イントラ予測は、現在ピクチャを参照しないMVに基づいており、現在ピクチャを参照するMV(存在する場合)を省略している。",
            "実施例９． ATMVPのプロセス内",
            "(a)隣接するブロックは、CPRを使用する場合、利用できないものとして扱われる。",
            "(b)配置された（collocated）ピクチャにおけるブロックがCPRを使用している場合である。",
            "(i)ATMVPプロセスにおいて利用できないものとして扱われ得る。",
            "(ii)利用可能であるとして扱われ得る。そして、現在ブロックまたはサブブロックについてそのブロックからMV'が導出され得る。",
            "(1)一つの例において、MV'は、現在ピクチャを参照し、かつ、配置されたピクチャ内のブロックからコピーされる。",
            "実施例１０． CPRが、（参照ピクチャリスト内で特定の参照ピクチャとして示されている代わりに）イントラモード、インターモードに加えて、新たなモードとしてコード化される場合、CPRモードの信号をスキップするか否かは、他のコーディング方法のデコードされた情報に依存する。",
            "(a)一つの例において、他のコーディング方法は、例えば、アフィンフラグ、インター－イントラ予測フラグ、不均等な重み付けを表すGBIインデックス、MMVD、ATMVPを含み得る。",
            "(b)１つのブロックに他のコーディング方法のいずれかが適用される場合、このブロックについてCPRモードのシグナリングはスキップされる。",
            "(c)代替的に、他のコーディング方法の使用のシグナリングをスキップするか否かは、CPRモードのデコードされた情報に依存し得る。",
            "実施例１１． ルマ成分およびクロマ成分、分離したコーディング構造ツリーを用いてコード化されている場合",
            "(a)一つの例において、クロマ成分がコード化される場合、MV予測またはマージ候補として、ルマ成分の対応するブロックのMV情報(MVは現在ピクチャを参照し得る)が使用され得る。",
            "(i)ルマ成分の対応するブロックは、現在クロマブロック内の任意の位置(上左、上右、下左、下右、または中央、といったもの)に存在し得る。",
            "(1)カラーフォーマットが4:4:4でない場合、対応するルマブロックを見つけるために、現在クロマブロックがスケーリングされるべきである。",
            "(ii)一つの例において、現在クロマブロックについてMV予測またはマージ候補として機能するルマ成分のいくつかの対応するブロックからのMV情報が存在し得る。それらのどれが選択されるかは、デコーダに対して信号化されるか、または、デコーダで導出され得る。",
            "(b)CPRを使用するクロマブロックの幅／高さは制約を有し得る。",
            "(i)一つの例において、CPRを使用するクロマブロックの幅／高さは、イントラコード化されたクロマブロックとは異なって制限され得る。",
            "(ii)一つの例においては、イントラコード化ブロックについて、幅＞２かつ（&&）高さ＞２であるが、CPRコード化ブロックについて、幅≧２かつ高さ≧２である。",
            "上述の例は、以下に説明される方法のコンテキストにおいて組み込まれ得る。例えば、ビデオデコーダまたはビデオエンコーダで実装され得る、方法2400、2500、2600、および2700である。",
            "図24は、ビデオ処理のための一つの例示的な方法に係るフローチャートを示している。方法2400は、ステップ2410において、現在ビデオブロックと、現在ビデオブロックのコーディングまたはデコーディングの最中の現在ピクチャ参照(CPR)の適用可能性を指定する第１コーディングと一貫性がある現在ビデオブロックのビットストリーム表現との間の変換を実行することを含み、ここで、第１コーディング規則は、以下のうち少なくとも１つを指定する(a)変換の最中にCPRおよびアフィン動き補償を同時に使用することを控えること、または(b)変換のために、コーディングのためにCPRを使用する隣接ブロックのアフィンモデルを継承することをディセーブルすること、または(c)変換のために、コーディング条件が満たされた場合にだけ隣接ブロックのアフィンモデルを継承すること、または(d)変換のためにCPRおよび一般化双予測(GBi)を同時に使用することを控えることであり、ここで、GBiは不均に重み付けされた参照ピクチャを使用すること、または(e)CPRおよび動きベクトル差異とのマージ（MMVD）モードを同時に使用することを控えること、または(f)CPRおよびMMVDモードを同時に使用すること、または(g)CPRおよびインター－イントラ予測を同時に使用することを控えること、または(h)CPRおよびインター－イントラ予測を同時に使用すること、または、(i)代替的な時間的動きベクトル予測子を併同時に使用すること、である。",
            "いくつかの実施形態において、および実施例1のコンテキストにおいて、整数精度（integer precision）が、コーディング規則(a)のために使用される。",
            "いくつかの実施形態において、および実施例6のコンテキストにおいて、MMVDモードは、コーディング規則(e)または(f)のための単一予測を含む。",
            "いくつかの実施形態において、および実施例8のコンテキストにおいて、インター－イントラ予測は、コーディング規則(g)および(h)のためのイントラ予測部分およびインター予測部分を含む。一つの実施例において、イントラ予測部分は境界フィルタリングを除外している。別の例において、イントラ予測部分は、位置依存予測の組み合わせを除外している。さらに別の例において、イントラ予測部分は、最確（most probable）モード選択、DC予測モード、水平予測モード、または垂直予測モードを含んでいる。さらに別の例において、インター予測部分は、単一予測を含んでいる。",
            "図25は、ビデオ処理のための別の例示的な方法に係るフローチャートを示している。方法2500は、ステップ2510において、現在ビデオブロックの隣接ブロックが、現在ピクチャ参照モードを使用してコード化されることを決定することを含む。",
            "方法2500は、ステップ2520において、決定に基づいて、マージ候補を導出することを含む。いくつかの実施形態において、および実施例2のコンテキストにおいて、マージ候補は、隣接ブロックの第２アフィンモデルとは異なる第１アフィンモデルを含む。一つの例において、マージ候補は、アフィンマージ候補を含み、そして、ここで、マージ候補リストは、サブブロックマージ候補リストを含む。別の例において、マージ候補は、アフィンAMVP候補を含み、そして、ここで、マージ候補リストは、アフィンAMVP候補リストを含む。",
            "いくつかの実施形態において、および実施例9のコンテキストにおいて、マージ候補は、代替的な時間的動きベクトル予測(ATMVP)候補を含み得る。",
            "方法2500は、ステップ2530において、マージ候補をマージ候補リストの中へ挿入することを含む。",
            "方法2500は、ステップ2540において、マージ候補リストに基づいて、現在ビデオブロックを再構成することを含む。",
            "いくつかの実施形態において、および実施例3のコンテキストにおいて、隣接ブロックは、双予測を適用し、そして、方法2500は、さらに、第１参照ピクチャリストまたは第２参照ピクチャリストに基づいて、マージ候補のアフィンモデルを決定するステップを含む。一つの例において、第１参照ピクチャリストは、現在ビデオブロックの現在ピクチャを含み、そして、アフィンモデルは、第２参照ピクチャリスト内の少なくとも１つのピクチャに基づいて決定される。別の例において、マージ候補は、AMVP候補を含み、そして、マージ候補リストは、アフィンAMVP候補リストを含む。",
            "図26は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法2600は、ステップ2610において、第１コーディングモードおよび第１コーディングモードとは異なる第２コーディングモードを用いてコード化される現在ビデオブロックの第１コーディングモードをデコーディングすることによって、デコードされた情報を生成することを含む。",
            "方法2600は、ステップ2620において、デコードされた情報に基づいて、第１コーディングモードまたは第２コーディングモードが現在ビデオブロックのビットストリーム表現で信号化されるか否かを決定することを含む。",
            "方法2600は、ステップ2630において、決定に基づいて、現在ビデオブロックを再構成することを含む。",
            "いくつかの実施形態において、および実施例10のコンテキストにおいて、第1コーディングモードは、アフィン・コーディングモード、インター－イントラ予測モード、不均等重み付けを用いる一般化された双予測の予測モード、動きベクトル差異モードまたは代替的な時間的動きベクトル予測モードとのマージ、を含み、第2コーディングモードは、CPRモードを含み、そして、ビットストリーム表現は、CPRモードに対するフラグを除外している。",
            "いくつかの実施形態において、および実施例10のコンテキストにおいて、第１コーディングモードは、現在ピクチャ参照(CPR)モードを含み、第２コーディングモードは、アフィン・コーディングモード、インター－イントラ予測モード、不均等重み付けを用いる一般化された双予測の予測モード、動きベクトル差異モードまたは代替的な時間的動きベクトル予測モードとのマージ、を含み、そして、ビットストリーム表現は、第２コーディングモードに対するフラグを除外している。",
            "図27は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。この方法2700は、ステップ2710において、現在ビデオブロックが、第１コーディング構造ツリーを使用してコード化されるルマ成分、および、第１コーディング構造ツリーとは異なる第２コーディング構造ツリーを使用してコード化されるクロマ成分を含むこと、を決定することを含む。",
            "方法2700は、ステップ2720において、決定に基づいて、現在ビデオブロックを再構成することを含む。いくつかの実施形態において、および実施例11のコンテキストにおいて、再構成することは、ルマ成分の１つ以上の対応するブロックから導出される動きベクトル情報に基づいて、クロマ成分をデコーディングすることを含む。一つの例において、ルマ成分の１つ以上の対応するブロックは、現在ビデオブロックの左上の位置、右上の位置、左下の位置、右下の位置、または中央の位置に存在している。別の例において、方法2700は、さらに、クロマ成分のカラーフォーマットが4:4:4カラーフォーマットとは異なっていると判定すると、ルマ成分の１つ以上の対応するブロックを決定するように現在ビデオブロックをスケーリングするステップを含む。",
            "いくつかの実施形態において、および実施例11のコンテキストにおいて、現在ビデオブロックは、現在ピクチャ参照（CPR）モードを使用してコード化される。一つの例において、現在ビデオブロックの高さと幅における制限の第１セットは、現在ビデオブロックとは異なるイントラコード化ビデオブロックの高さと幅における制限の第２セットとは異なるものである。",
            "５． 開示された技術の実施例 図28は、ビデオ処理装置2800のブロック図である。装置2800は、ここにおいて説明された１つ以上の方法を実装するために使用され得る。装置2800は、スマートフォン、タブレット、コンピュータ、モノのインターネット(IoT)受信器、等において具現化され得る。装置2800は、１つ以上のプロセッサ2802、１つ以上のメモリ2804、および、ビデオ処理ハードウェア2806を含み得る。プロセッサ2802は、本文書において説明された１つ以上の方法(方法2400、2500、2600、および2700を含むが、これらに限定されない)を実装するように構成され得る。メモリ(複数のメモリ)2804は、ここにおいて説明された方法および技術を実装するために使用されるデータおよびコードを保管するために使用され得る。ビデオ処理ハードウェア2806は、ハードウェア回路において、本文書において説明されたいくつかの技術を実装するために使用され得る。",
            "図29は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法2900は、ステップ2910において、イントラブロックコピー(Intra-Block-Copy、IBC)モードがビデオの現在ビデオブロックに適用されることを決定することを含み、ここでは、IBCモードにおいて、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、現在ビデオブロックがその中に配置されている現在ピクチャである。ステップ2920においては、現在ブロックに対する特定のコーディングモードをディセーブルすることに関する決定を行うことを含む。ステップ2930においては、決定に基づいて、現在ビデオブロックとビットストリーム表現との間で変換を実行することを含み、ここで、特定のコーディングモードは、ビデオブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する。",
            "図30は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3000は、ステップ3010において、現在ビデオブロックが特定のコーディングモードを使用してコード化されることを決定することを含む。ステップ3020においては、決定に基づいて、現在ブロックに対するイントラブロックコピー(IBC)モードをディセーブルすることに関する決定を行うことを含み、ここでは、IBCモードにおいて、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、現在ビデオブロックがその中に配置されている現在ピクチャである。ステップ3030においては、決定に基づいて、現在ブロックとビットストリーム表現との間の変換を実行することを含み、ここで、特定のコーディングモードは、現在ブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する。",
            "図31は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3100は、ステップ3110において、現在ビデオブロックのアフィンモードを決定することを含み、ここで、現在ビデオブロックが隣接ブロックからアフィンモードを継承するか否かは、参照リストに依存する。ステップ3120においては、ビデオの現在ビデオブロックと、決定に基づいて一貫したビデオのビットストリーム表現との間の変換を実行する。",
            "図32は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3200は、ステップ3210において、ビデオの現在ビデオブロックと、一貫したビデオのビットストリーム表現との間の変換を実行することを含む。ここでは、変換の最中に、イントラブロックコピー（IBC）モードおよび動きベクトル差異とのマージ（MMVD）モードが使用され、そして、ここでは、IBCモードにおいて、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、MMVDモードにおいては、ビデオブロックの動きベクトルが、マージ動き候補リストに基づいて導出され、そして、少なくとも１つの動きベクトル差異によってさらに改良される。",
            "図33は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3300は、ステップ3310において、ビデオの現在ビデオブロックと、ビデオのビットストリーム表現との間の変換を実行することを含む。ここでは、変換の最中に、イントラブロックコピー(IBC)モードおよびインター－イントラ予測モードが使用され、そして、ここで、IBCモードにおいて、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、インター－イントラ予測モードにおいては、現在ビデオブロックの予測信号が、イントラ予測信号およびインター予測信号に少なくとも基づいて生成される。",
            "図34は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3400は、ステップ3410において、現在ビデオブロックと現在ビデオブロックのビットストリーム表現との間の変換の最中に、IBCモードとは異なる少なくとも１つのコーディング方法のデコードされた情報を決定することを含み、ここで、IBCモードにおいて、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、現在ビデオブロックがその中に配置されている現在ピクチャである。ステップ3420においては、デコードされた情報に基づいて、現在ビデオブロックのビットストリーム表現における現在ビデオブロックに対するIBCフラグのシグナリングをスキップするか否かを決定することを含み、ここで、IBGフラグはIBモードに関連している。そして、ステップ3430においては、決定に基づいて、変換を実行することを含む。",
            "図35は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3500は、ステップ3510において、現在ビデオブロックと現在ビデオブロックのビットストリーム表現との間の変換の最中に、ここで、現在ビデオブロックは、第１コーディング構造ツリーを使用してコード化されたルマ成分、および、第１コーディング構造ツリーとは異なる第２コーディング構造ツリーを使用してコード化されたクロマ成分を含み、現在ビデオブロックのルマ成分の１つ以上の対応するブロックの第２動きベクトル情報からクロマブロックに対する第１動きベクトル情報を導出することを含む。ステップ3520においては、第１動きベクトル情報および第２ベクトル情報に基づいて、変換を実行することを含む。",
            "図36は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3600は、ステップ3610において、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、現在ビデオブロックがその中に配置されているピクチャと同一である、イントラブロックコピー（IBC）モードを、現在ビデオブロックに適用するか否かを決定することを含む。ステップ3620においては、IBCモードが現在ビデオブロックに適用されるか否かをシグナリングすることを含む、ステップ3630においては、IBCモードが現在ビデオブロックに適用されることを決定することに基づいて、予測モードのグループに対してフラグをシグナリングすることを控えることを含む。そして、ステップ3640においては、IBCモードの適用に基づいて、現在ビデオブロックに対して変換を実行することを含む。",
            "図37は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3700は、ステップ3710において、現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、現在ビデオブロックがその中に配置されているピクチャと同一である、イントラブロックコピーモードが、現在ビデオブロックに適用されるかどうかを決定するためにビットストリームを解析することを含む。ステップ3720においては、IBCモードの適用に基づいて、現在ビデオブロックに対して変換を実行することを含み、ここで、予測モードのグループに対するフラグは、現在ビデオブロックに対してCPRが適用されることを決定することに基づいて、ビットストリームから除外される。",
            "図38は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3800は、ステップ3810は、現在ビデオブロックと現在ビデオブロックのビットストリーム表現との間の変換の最中に、現在ビデオブロックの動き情報を獲得するプロセスであり、ここで、現在ビデオブロックの動き情報は、現在ビデオブロックの少なくとも１つの隣接ブロックに係る少なくとも１つのアフィンモデルに基づいている。ステップ3820においては、現在ビデオブロックの隣接するブロックが、イントラブロックコピー(IBC)モードを使用するか否かを決定することを含み、そこでは、隣接するビデオブロックによって使用される少なくとも１つの参照ピクチャが、その中に隣接するブロックが配置されているピクチャと同一である。ステップ3830においては、現在ビデオブロックについて、隣接するブロックがIBCモードを使用することを決定することに基づいて、隣接するブロックからアフィン候補を導出することをディセーブルすることを含む。そして、ステップ3830においては、現在ビデオブロックの動き情報に基づいて、変換を実行することを含む。",
            "図39は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法3900は、ステップ3910において、現在ビデオブロックと、サブブロックベースの時間的動きベクトル予測(SbTMVP)モードに基づく現在ビデオブロックのビットストリーム表現との間の変換の最中に、現在ビデオブロックをサブブロックへと分割することを含む。ステップ3920においては、現在ビデオブロックの空間的隣接ブロックの動き情報に基づいて、サブブロックについて、時間的ベクトルを伴う動きソース（source）ピクチャにおいて対応するブロックを識別することを含み、ステップ3930においては、対応するブロックのコード化情報に基づいて、サブブロックの対応するブロックから、動きベクトルおよび参照インデックスの参照インデックスを生成することを含み、ステップ3940においては、生成された動きベクトルおよび参照インデックスに基づいて、変換を実行することを含む。",
            "図40は、ビデオ処理のためのさらに別の例示的な方法に係るフローチャートを示している。方法4000は、ステップ4010において、現在ビデオブロックと、サブブロックベースの時間的動きベクトル予測(SbTMVP)モードに基づく現在ビデオブロックのビットストリーム表現との間の変換の最中に、現在ビデオブロックをサブブロックへと分割することを含む。ステップ4020においては、現在ビデオブロックの空間的隣接ブロックのコード化情報に基づいて、サブブロックについて、時間的ベクトルを伴う動きソースピクチャにおいて対応するブロックを識別することを含み、ステップ4030において、サブブロックの対応するブロックから、動きベクトルおよびサブブロックの参照インデックスを生成することを含み、ステップ4040においては、生成された動きベクトルおよび参照インデックスに基づいて、変換を実行することを含む。",
            "いくつかの実施形態において、ビデオコーディング方法は、図28に関して説明したように、ハードウェアプラットフォーム上で実装される装置を使用して実施され得る。",
            "いくつかの実施形態は、以下の実施例を使用して説明され得る。",
            "1.1. ビデオ処理のための方法であって、ビデオの現在ビデオブロックに対してイントラブロックコピー（IBC）モードが適用されることを決定するステップであり、前記IBCモードにおいて、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ビデオブロックが配置されている現在ピクチャである、ステップと、前記現在ビデオブロックに対する特定のコーディングモードをディセーブルすることに関する決定を行うステップと、前記決定に基づいて、前記現在ビデオブロックとビットストリーム表現との間で変換を実行するステップと、を含み、前記特定のコーディングモードは、ビデオブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する、方法。",
            "1.2. 前記変換は、前記現在ビデオブロックを前記ビットストリーム表現へと符号化するステップ、を含む、例1.1の方法。",
            "1.3. 前記変換は、前記現在ビデオブロックのピクセル値を生成するために、前記現在ビデオブロックの前記ビットストリーム表現を復号化するステップ、を含む、例1.1の方法。",
            "1.4. 前記特定のコーディングモードは、アフィン動き補償モードを含み、前記アフィン動き補償モードは、少なくとも１つの制御点動きベクトルを使用する、例1.1-1.3いずれかの方法。",
            "1.5. 参照ピクチャインデックスが信号化され、かつ、前記IBCモードを使用している現在ビデオブロックに応答して、アフィンフラグの前記信号化がスキップされる、例1.4の方法。",
            "1.6. 前記方法は、さらに、前記アフィンフラグが信号化される前に、参照ピクチャインデックスを信号化するステップと、前記現在ビデオブロックについて双予測モードが使用されているか否かを判定するステップと、を含み、前記現在ビデオブロックについて双予測モードが使用されており、かつ、１つの参照ピクチャだけ現在参照ピクチャである場合に、前記アフィンフラグが信号化され、 前記現在ビデオブロックについて双予測モードが使用されており、かつ、両方の参照ピクチャが現在参照ピクチャである場合、前記アフィンフラグは信号化されない、例1.4の方法。",
            "1.7. 前記現在ビデオブロックの動きベクトルについて整数精度が使用されている、例1.6の方法。",
            "1.8. 前記特定のコーディングモードは、GBiモードを含み、前記GBiモードにおいては、異なる重み付け値が異なる参照ピクチャと関係している、例1.1-1.7いずれかの方法。",
            "1.9. 前記現在ビデオブロックにおいて使用されている前記IBCモードに応答して、GBi重み付けインデックスが信号化されない、例1.8の方法。",
            "1.10. 前記GBi重み付けインデックスがゼロであると推定される、例1.8の方法。",
            "1.11. 前記特定のコーディングモードは、動きベクトル差異（MMVD）モードとのマージを含み、前記MMVDモードにおいては、ビデオブロックの動きベクトルが、マージ動き候補リストに基づいて導出され、かつ、少なくとも１つの動きベクトル差異によってさらに精密化される、例1.1-1.10いずれかの方法。",
            "1.12. 前記現在ビデオブロックにおいて使用されている前記IBCモードに応答して、MMVDフラグが信号化されない、例1.11の方法。",
            "1.13. 前記MMVDフラグは、ゼロであると推定される、例1.12の方法。",
            "1.14. 前記特定のコーディングモードは、結合されたインター－イントラ予測（CIIP）モードを含み、前記CIIPモードにおいては、少なくともイントラ予測信号およびインター予測信号に基づいて、前記現在ビデオブロックの予測信号が生成される、例1.1-1.13いずれかの方法。",
            "1.15. 前記現在ビデオブロックにおいて使用されている前記IBCモードに応答して、前記現在ビデオブロックに対するCIIPフラグが信号化されない、例1.14の方法。",
            "1.16. 前記CIIPフラグは、ゼロであると推定される、例1.15の方法。",
            "1.17. ビデオ処理のための方法であって、現在ビデオブロックが特定のコーディングモードを使用して符号化されることを決定するステップと、前記決定に基づいて前記現在ブロックについてイントラブロックコピー（IBC）モードをディセーブルすることに関する決定を行うステップであり、前記IBCモードにおいて、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ブロックが配置されている現在ピクチャである、ステップと、 前記決定に基づいて、前記現在ブロックとビットストリーム表現との間で変換を実行するステップと、を含み、前記特定のコーディングモードは、前記現在ブロックの予測を導出するために、動きベクトルおよび非現在ピクチャを使用する、方法。",
            "1.18. 前記変換は、前記現在ビデオブロックを前記ビットストリーム表現へと符号化するステップ、を含む、例1.17の方法。",
            "1.19. 前記変換は、前記現在ビデオブロックのピクセル値を生成するために、前記現在ビデオブロックの前記ビットストリーム表現を復号化するステップ、を含む、例1.17の方法。",
            "1.20. 前記特定のコーディングモードは、アフィン動き補償モードを含み、前記アフィン動き補償モードは、少なくとも１つの制御点動きベクトルを使用する、例1.1-1.3いずれかの方法。",
            "1.21. ブロックレベルにおけるアフィンフラグは、前記ビットストリームにおいて信号化され、前記現在ビデオブロックに対してアフィン動き補償モードがイネーブルされているか否かを示しており、かつ、前記現在ビデオブロックに対して前記アフィン動き補償モードがイネーブルされていることを、前記アフィンフラグが示す場合には、前記IBCモードが適用されるか否かは信号化されない、例1.20の方法。",
            "1.22. 前記特定のコーディングモードは、GBiモードを含み、前記GBiモードにおいては、異なる重み付け値が異なる参照ピクチャと関係している、例1.17-1.19いずれかの方法。",
            "1.23. 適用されている前記GBIモードに応答して、IBC指示は信号化されない、例1.22の方法。",
            "1.24. 前記IBC指示は、ゼロであると推定される、例1.23の方法。",
            "1.25. 前記特定のコーディングモードは、動きベクトル差異（MMVD）モードとのマージを含み、前記MMVDモードにおいては、前記現在ブロックの動きベクトルが、マージ動き候補リストに基づいて導出され、かつ、少なくとも１つの動きベクトル差異によってさらに精密化される、例1.17-1.24いずれかの方法。",
            "1.26. 前記現在ビデオブロックにおいて適用されている前記MMVDモードに応答して、IBC指示が信号化されない、例1.25の方法。",
            "1.27. 前記IBC指示は、ゼロであると推定される、例1.26の方法。",
            "1.28. 前記特定のコーディングモードは、結合されたインター－イントラ予測（CIIP）モードを含み、前記CIIPモードにおいては、少なくともイントラ予測信号およびインター予測信号に基づいて、前記現在ビデオブロックの予測信号が生成される、例1.17-1.27いずれかの方法。",
            "1.29. 適用されている前記インター－イントラ予測モードに応答して、前記現在ビデオブロックに対するIBCフラグが信号化されない、例1.28の方法。",
            "1.30. 前記IBCフラグは、ゼロであると推定される、例1.29の方法。",
            "1.31. ビデオ処理のための方法であって、現在ビデオブロックのアフィンモードを決定するステップであり、前記現在ビデオブロックが隣接ブロックからアフィンモードを継承するか否かは、参照リストに依存する、ステップと、ビデオの現在ビデオブロックと、前記決定に基づいて一貫したビデオのビットストリーム表現との間の変換を実行するステップと、を含む、方法。",
            "1.32. 前記隣接ブロックは、双予測を適用し、参照リストXにおける参照ピクチャは、現在ピクチャであり、かつ、参照リスト（1-X）における参照ピクチャは、前記現在ピクチャではなく、ここで、Xが、0または1である、例1.31の方法。",
            "1.33. 前記参照リストXを参照する前記隣接ブロックの動き情報は、サブブロックマージ候補リストにおけるアフィンマージ候補を導出するために使用されない、例1.32の方法。",
            "1.34. 前記参照リスト（1-X）を参照する前記隣接ブロックの動き情報は、前記サブブロックマージ候補リストにおける前記アフィンマージ候補を導出するために使用される、例1.32または1.33の方法。",
            "1.35. 前記参照リストXを参照する前記隣接ブロックの動き情報は、アフィンAMVPリストにおいてアフィンAMVP候補を導出するためには使用されない、例1.32の方法。",
            "1.36. 前記参照リストXを参照する前記隣接ブロックの前記動き情報は、前記参照リストXについて、前記アフィンAMVPリストにおいて前記アフィンAMVP候補を導出するためには使用されない、例1.35の方法。",
            "1.37. 前記参照リスト（1-X）を参照する前記隣接ブロックの動き情報は、アフィンAMVPリストにおいてアフィンAMVP候補を導出するために使用される、例1.32の方法。",
            "1.38. 前記参照リスト（1-X）を参照する前記隣接ブロックの動き情報は、前記参照リスト（1-X）に対する前記アフィンAMVPリストにおける前記アフィンAMVP候補を導出するために使用される、例1.37の方法。",
            "1.39. ビデオ処理のための方法であって、ビデオの現在ビデオブロックと、前記現在ビデオブロックのビットストリーム表現との間の変換を実行するステップ、を含み、前記変換の最中には、イントラブロックコピー（IBC）モード、および、動きベクトル差異とのマージ（MMVD）モードが使用され、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャは、前記現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、前記MMVDモードでは、ビデオブロックの動きベクトルが、マージモーション候補リストに基づいて導出されて、さらに、少なくとも１つの動きベクトル差異によって精密化される、方法。",
            "1.40. 前記MMVDモードは、前記現在ピクチャを参照する少なくとも１つの参照ピクチャを有するベースMV候補を使用する、例1.39の方法。",
            "1.41. 前記MMVDは、前記現在ピクチャを参照する少なくとも１つのMVに基づいており、かつ、前記現在ピクチャを参照しないMVは、存在する場合には、省略される、例1.40の方法。",
            "1.42. 前記MMVDによって信号化される距離は整数である、例1.41の方法。",
            "1.43. 前記MMVDは、単一予測される、例1.41の方法。",
            "1.44. 前記MMVDモードが、前記現在ピクチャを参照しない少なくとも１つの参照ピクチャを有するベースMV候補を使用する場合、前記MMVDは、前記現在ピクチャを参照しない少なくとも１つのMVに基づいており、かつ、前記現在ピクチャを参照するMVは、存在する場合には、省略される、例1.39の方法。",
            "1.45. ビデオ処理のための方法であって、ビデオの現在ビデオブロックと前記ビデオのビットストリーム表現との間の変換を実行するステップ、を含み、前記変換の最中には、イントラブロックコピー（IBC）モードおよびインター－イントラ予測モードが使用され、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックがその中に配置されている現在ピクチャであり、かつ、前記インター－イントラ予測モードでは、前記現在ビデオブロックの予測信号は、少なくともイントラ予測信号およびインター予測信号に基づいて生成される、方法。",
            "1.46. 前記インター－イントラ予測されるマージ候補は、前記現在ピクチャを参照する少なくとも１つの参照ピクチャを有する、例1.45の方法。",
            "1.47. 前記インター－イントラ予測は、前記現在ピクチャを参照する少なくとも１つのMVに基づいており、かつ、前記現在ピクチャを参照しないMVは、存在する場合には、省略される、例1.46の方法。",
            "1.48. 前記インター－イントラ予測モードのイントラ予測部分は、境界フィルタリングを除外する、例1.45の方法。",
            "1.49. 前記インター－イントラ予測モードのイントラ予測部分は、位置依存予測組み合わせ（PDPC）を除外する、例1.45の方法。",
            "1.50. 前記インター－イントラ予測モードのイントラ予測部分は、最確モード選択（MPM）、DC予測モード、水平予測モード、または、垂直予測モードのうち少なくとも１つを含む、例1.45の方法。",
            "1.51. 前記インター－イントラ予測モードのインター予測部分は、単一予測される、例1.45の方法。",
            "1.52. インター－イントラ予測されるマージ候補が、前記現在ピクチャを参照しない少なくとも１つの参照ピクチャを有する場合、前記現在ピクチャを参照しない少なくとも１つのMVに基づくインター－イントラ予測が実行され、かつ、前記現在ピクチャを参照するMVは、存在する場合には、省略される、例1.45-1.51いずれかの方法。",
            "1.53. ビデオ処理のための方法であって、現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の最中に、IBCモードとは異なる少なくとも１つのコーディング方法のデコードされた情報を決定するステップであり、前記IBCモードでは、前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックがその中に配置されている現在ピクチャである、ステップと、前記デコードされた情報に基づいて、前記現在ビデオブロックのビットストリーム表現における前記現在ビデオブロックについてIBCフラグのシグナリングをスキップするか否かを決定するステップであり、前記IBCフラグは、IBモードに関連する、ステップと、前記決定に基づいて、前記変換を実行するステップと、を含む、方法。",
            "1.54. 前記変換は、前記現在ビデオブロックを前記ビットストリーム表現へと符号化することを含む、例1.53の方法。",
            "1.55. 前記変換は、前記現在ビデオブロックのピクセル値を生成するために、前記現在ビデオブロックの前記ビットストリーム表現をデコードすることを含む、例1.53の方法。",
            "1.56. 前記決定するステップにおいて、前記IBCフラグのシグナリングをスキップしないことを決定された場合、前記ビットストリーム表現における前記現在ビデオブロックについて前記IBCフラグをシグナリングし、さもなければ、前記ビットストリーム表現における前記現在ビデオブロックについて前記IBCフラグへのシグナリングすることを控える、例1.53-1.55いずれかの方法。",
            "1.57. 前記コーディング方法のデコードされた情報が、アフィンフラグ、インター－イントラ予測フラグ、一般化双予測（GBi）インデックス、動きベクトル差異（MMVD）情報とのマージ、代替的な時間的動きベクトル予測（ATMVP）情報のうちの少なくとも１つを含む場合に、前記IBCフラグのシグナリングをスキップすることが決定される、例1.53-1.56いずれかの方法。",
            "1.58. ビデオ処理のための方法であって、現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の最中に、前記現在ビデオブロックは、第１コーディング構造ツリーを使用してコード化されるルマ成分、および、前記第１コーディング構造ツリーとは異なる第２コーディング構造ツリーを使用してコード化されるクロマ成分を含み、前記現在ビデオブロックの前記ルマ成分の１つ以上の対応するブロックに係る第２動きベクトル情報からクロマブロックに対する第１動きベクトル情報を導出する、ステップと、前記第１動きベクトル情報および前記第２動きベクトル情報に基づいて、前記変換を実行するステップと、を含む、方法。",
            "1.59. 前記変換は、前記現在ビデオブロックを前記ビットストリーム表現へと符号化することを含む、例1.58の方法。",
            "1.60. 前記変換は、前記現在ビデオブロックのピクセル値を生成するために、前記現在ビデオブロックの前記ビットストリーム表現を復号化することを含む、例1.58の方法。",
            "1.61. 前記第１動きベクトル情報は、前記第２動きベクトル情報を導出するためのMV予測またはマージ候補として使用される、例1.58の方法。",
            "1.62. 前記ルマ成分の１つ以上の対応するブロックは、前記現在ビデオブロックの左上の位置、右上の位置、左下の位置、右下の位置、及び／又は、中心位置にある、例1.58-1.61いずれかの方法。",
            "1.63. 前記方法は、さらに、前記クロマ成分のカラーフォーマットが、4:4:4のカラーフォーマットと異なるか否かを判定するステップと、前記クロマ成分のカラーフォーマットが4:4:4のカラーフォーマットと異なっていると判定すると、前記ルマ成分の１つ以上の対応するブロックを決定するように、前記現在ビデオブロックをスケーリングするステップと、を含む、例1.62の方法。",
            "1.64. 前記現在ビデオブロックが、イントラブロックコピー（IBC）モードを使用してコード化される、例1.58-1.60いずれかの方法。",
            "1.65. 前記現在ビデオブロックの高さおよび幅における制限の第１セットは、前記現在ビデオブロックとは異なるイントラコード化ビデオブロックの高さおよび幅における制限の第２セットとは異なる、例1.64の方法。",
            "1.66. 前記現在ビデオブロックが、イントラブロックコピーモードを使用してコード化された場合に、前記現在ビデオブロックの前記幅は２より大きく、前記高さは２より大きく、かつ、前記現在ビデオブロックが前記IBCモードを使用してコード化された場合に、前記現在ビデオブロックの幅は２以上であり、前記高さは２以上である、例1.65の方法。",
            "1.67. ビデオシステムにおける装置であって、プロセッサと、命令が保管された非一時的メモリと、を備え、前記プロセッサによって実行されると、前記命令は、例1.1-1.66いずれかの方法を前記プロセッサに実行させる、 装置。",
            "1.68. 非一時的なコンピュータで読取り可能な媒体に保管されたコンピュータプログラム製品であって、例1.1-1.66いずれかの方法を実行するためのプログラムコードを含む、コンピュータプログラム製品。",
            "2.1 前記現在ビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記現在ビデオブロックが配置されているピクチャと同一であるイントラブロックコピーモード（IBC）を前記現在ビデオブロックに適用するかどうかを決定するステップと、前記IBCモードが前記現在ビデオブロックに適用されるかどうかをシグナリングするステップと、前記IBCモードが前記現在ビデオブロックに適用されることを決定することに基づいて、予測モードのグループに対するシグナリングフラグを控えるステップと、前記IBCモードの適用に基づいて、前記現在ビデオブロックの変換を実行するステップと、を含む、ビデオ処理方法。",
            "2.2. 前記変換は、前記現在ビデオブロックをビットストリーム表現に符号化することを含む、例2.1の方法。",
            "2.3 前記予測モードのグループは、アフィンモードを含み、前記アフィンモードは、少なくとも１つの制御点動きベクトルを使用する、例2.1または2.2の方法。",
            "2.4. 前記IBCモードが前記現在ビデオブロックに適用されるか否かを決定するステップは、アフィンフラグが信号化される前に行われ、前記方法は、前記IBCモードが前記現在ビデオブロックに適用されることが決定される場合には、前記アフィンフラグの信号化を差し控えるステップと、それ以外の場合には、前記アフィンフラグの信号化を差し控えるステップとをさらに含む、例2.3の方法。",
            "2.5.アフィンフラグが信号でない場合、アフィンフラグはゼロであると推定される、例2.4の方法。",
            "2.6. 前記予測モードのグループは、一般化された双予測モードを含み、前記GBIモードでは、異なる重み付け値は、異なる参照ピクチャに関連する、例2.1-2.5いずれかの方法。",
            "2.7. 前記IBCモードが前記現在ビデオブロックに適用されるか否かを決定するステップは、GBiインデックスが信号化される前に行われ、前記方法は、前記IBCモードが前記現在ビデオブロックに適用されることが決定される場合には、GBi重み付けインデックスの信号化を控え、その他の場合には、前記GBi重み付けインデックスの信号化を控えるステップをさらに含む、例2.6の方法。",
            "2.8. 前記GBi重み付けインデックスが信号化されていない場合、前記GBiによって使用される前記参照ピクチャの重み付け値はゼロであると推定される、例2.7の方法。",
            "2.9. ビットストリームを解析して、現在ビデオブロックによって使用されている少なくとも１つの参照ピクチャが、現在ビデオブロックが配置されているピクチャと同一であるかどうかを判定するステップと、現在ビデオブロックに対して変換を実行するステップとを含み、予測モードのグループに対するフラグは、CPRが現在ビデオブロックに対して適用されることを判定することに基づいて、ビットストリームから除外される、ビデオ処理方法。",
            "2.10. 前記変換は、前記現在ビデオブロックの前記ビットストリーム表現を復号して、前記現在ビデオブロックのピクセル値を生成することを含む、例2.9の方法。",
            "2.11. 前記予測モードのフラグがゼロであると推定される、例2.9または2.10の方法。",
            "2.12. 前記予測モードのグループは、少なくとも１つの制御点動きベクトルが使用されるアフィンモード、前記現在ビデオブロックの予測信号が少なくともイントラ予測信号およびインター予測信号に基づいて生成されるイントラ予測モード、不均等重み付けを有する一般化された双予測の予測モード、マージモーション候補リストに基づいてビデオブロックの動きベクトルが導出され、少なくとも１つの動きベクトル差異によってさらに精密化される動きベクトル差異を有するマージモード、および、前記現在ビデオブロックのサブブロックの動き情報が、前記現在ビデオブロックの空間的隣接ブロックの動き情報によって決定される対応するブロックに基づいて決定される代替的な時間的動きベクトル予測モードのうちの少なくとも１つを含む、例2.9-2.11いずれかの方法。",
            "2.13. プロセッサと、その上に命令を有する非一時的メモリとを備えるビデオシステム内の装置であって、前記プロセッサによる実行の際に、前記命令によって、前記プロセッサは、例2.1-2.12いずれかの方法を実施させる、装置。",
            "2.14. コンピュータプログラム製品であって、非一時的なコンピュータで読取り可能な媒体に保管されたものであり、例2.1-2.12いずれかの方法を実行するためのプログラムコードを含むもの。",
            "2.15. 例2.1-2.12の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオデコーディング装置。",
            "2.16. 例2.1-2.12の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオコーディング装置。",
            "3.1. 現在ビデオブロックの動き情報を取得するプロセスにおいて、前記現在ビデオブロックと前記現在ビデオブロックのビットストリーム表現との間の変換の間に、前記現在ビデオブロックの前記動き情報が、前記現在ビデオブロックの少なくとも１つの隣接するブロックの少なくとも１つのアフィンモデルに基づいており、前記現在ビデオブロックの隣接するブロックが、前記隣接するビデオブロックによって使用される少なくとも１つの参照ピクチャが、前記隣接するブロックが配置されているピクチャと同一であるイントラブロックコピーモード（IBC）を使用するかどうかを決定するステップと、前記現在ビデオブロックに対して、前記隣接するビデオブロックが前記IBCモードを使用することを決定することに基づいて、前記隣接するブロックからアフィン候補を導出することを無効にするステップと、前記変換を、前記現在ビデオブロックの動き情報に基づいて実行するステップとを含む、ビデオ処理方法。",
            "3.2. 前記変換は、前記現在ビデオブロックをビットストリーム表現に符号化することを含む、例3.1の方法。",
            "3.3. 前記変換は、前記現在ビデオブロックの前記ビットストリーム表現を復号化して、前記現在ビデオブロックのピクセル値を生成することを含む、例3.1の方法。",
            "3.4. 前記方法は、さらに、隣接するブロックがIBCモードを使用しないという決定に基づいて、隣接するブロックから現在ビデオブロックに対するアフィン候補を導出することを含む、例3.1-3.3いずれかの方法。",
            "3.5. アフィン候補がアフィンマージ候補を含み、アフィン候補がサブブロックマージ候補リストにある、例3.1-3.4いずれかの方法",
            "3.6. 隣接ブロックがIBCモードを使用することを決定することに基づいて、隣接ブロックが使用不可として扱われる、実施例3.5の方法。",
            "3.7. アフィン候補がアフィンAMVP候補を含み、アフィン候補がアフィンAMVPリストにある、例3.1-3.4いずれかの方法。",
            "3.8. 隣接ブロックがIBCモードを使用することを決定することに基づいて、隣接ブロックが使用不可として扱われる、例3.7の方法。",
            "3.9. プロセッサと、その上に命令を有する非一時的メモリとを備えるビデオシステム内の装置であって、前記プロセッサによる実行の際に、前記命令によって、前記プロセッサは、例3.1-3.8いずれかの方法を実施させる、装置。",
            "3.10. 非時間的コンピュータで読取り可能な媒体に保管されたコンピュータプログラム製品であって、例3.1-3.8いずれかの方法を実行するためのプログラムコードを含むコンピュータプログラム製品。",
            "3.11. 例3.1-3.8の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオデコーディング装置。",
            "3.12. 例3.1-3.8の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオコーディング装置。",
            "4.1. 現在ビデオブロックを、サブブロックに基づく時間的動きベクトル予測(SbTMVP)モードに基づく現在ビデオブロックのビットストリーム表現との間の変換の最中に、サブブロックに分割するステップと、現在ビデオブロックの空間的隣接ブロックの動き情報に基づいて、時間的ベクトルを有する動きソースピクチャにおいて、対応するブロックを識別するステップと、前記サブブロックの対応するブロックのコーディングモード情報に基づいて、前記サブブロックの動きベクトルおよび参照インデックスを前記サブブロックの前記対応するブロックから生成するステップと、前記生成された動きベクトルおよび参照インデックスに基づいて前記変換を実行するステップと、を含む、ビデオ処理方法。",
            "4.2. 前記動きソースピクチャは、現在ビデオブロックのコロケーションされた参照ピクチャである、例4.1の方法。",
            "4.3. 前記対応するブロックは、イントラブロックコピー(IBC)モードでコード化され、前記対応するブロックの参照ブロックは、前記対応するブロックを含むピクチャ内に少なくとも１つのピクセルを含む、例4.1-4.2いずれかの方法。",
            "4.4. 前記変換の最中に、前記対応するブロックを利用不能として処理するステップをさらに含む、例4.3の方法。",
            "4.5. 前記対応するブロックから前記サブブロックの動きベクトルおよび前記参照ピクチャを導出することを控えることをさらに含む、例4.4の方法。",
            "4.6. デフォルトの動き情報を現在ビデオブロックに割り当てるステップをさらに含む、例4.5の方法。",
            "4.7. 前記対応するブロックは、利用可能なものとして取り扱われ、前記サブブロックの動きベクトルおよび前記参照ピクチャは、前記対応するブロックから導出される、例4.3の方法。",
            "4.8. 前記サブブロックの動きベクトルは、前記対応するブロックに関連付けられたものからコピーされる、例4.7の方法。",
            "4.9. 前記空間的隣接ブロックは、IBCモードを使用する場合、使用不可として扱われ、前記空間的隣接ブロックの基準ブロックは、前記空間的ブロックを含むピクチャ内に少なくとも１つのピクセルを含む、例4.1の方法。",
            "4.10. サブブロックベースの時間的動きベクトル予測(SbTMVP)モードに基づいて、現在ビデオブロックと現在ビデオブロックのビットストリーム表現との間の変換の最中に、現在ビデオブロックをサブブロックに分割するステップと、現在ビデオブロックの空間的隣接ブロックのコーディングモード情報に基づいて、時間的ベクトルを有する動きソースピクチャにおいて、対応するブロックを識別するステップと、前記サブブロックの対応するブロックから、前記サブブロックの動きベクトルおよび参照インデックスを生成するステップと、前記生成された動きベクトルおよび参照インデックスに基づいて前記変換を実行するステップと、を含むことを特徴とするビデオ処理方法。",
            "4.11. 前記動きソースピクチャは、現在ビデオブロックのコロケーションされた参照ピクチャである、例4.10の方法。",
            "4.12. 前記空間的隣接ブロックは、イントラブロックコピー(IBC)モードで符号化され、前記空間的隣接ブロックの参照ブロックは、前記空間的隣接ブロックを含むピクチャ内に少なくとも１つの画素を含む、例4.10-4.11いずれかの方法。",
            "4.13. 前記空間的隣接ブロックを前記変換の最中に利用不能として処理するステップをさらに含む、例4.12の方法。",
            "4.14. 空間的隣接ブロックの動きベクトルに基づいて対応するブロックを識別することを控えることをさらに含む、例4.13の方法。",
            "4.15. デフォルト動き情報が、対応するブロックを識別するために割り当てられることをさらに含む、例4.14の方法。",
            "4.16. 前記変換は、現在ビデオブロックをビットストリーム表現に符号化することを含む、例4.1-4.15いずれかの方法。",
            "4.17. 前記変換は、前記現在ビデオブロックのビットストリーム表現を復号して、前記現在ビデオブロックのピクセル値を生成することを含む、例4.1-4.15いずれかの方法。",
            "4.18. プロセッサと、その上に命令を有する非一時的メモリとを備えるビデオシステム内の装置であって、前記プロセッサにより実行されると、前記命令によって、前記プロセッサは、例4.1-4.15いずれかの方法を実施させる、装置。",
            "4.19. 非一時的なコンピュータで読取り可能な媒体に保管されたコンピュータプログラム製品であって、例4.1-4.15いずれかの方法を実施するためのプログラムコードを含む、コンピュータプログラム製品。",
            "4.20. 例4.1-4.15の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオデコーディング装置。",
            "4.21. 例4.1-4.15の１つ以上の方法を実施するように構成されたプロセッサを含む、ビデオコーディング装置。",
            "以上から、ここにおいては、説明の目的で、本開示の技術の特定の実施形態を説明してきたが、本発明の範囲を逸脱することなく、種々の修正を行うことができることが理解されるであろう。従って、現在開示されている技術は、添付の請求項による場合を除き、限定されるものではない。",
            "この特許文書に記載されている技術的事項（subject matter）の実装および機能動作は、ここにおいて開示されている構造およびそれらの構造的等価物を含む、種々のシステム、デジタル電子回路、またはコンピュータソフトウェア、ファームウェア、もしくはハードウェアにおいて、または、それらの１つ以上の組み合わせにおいて実施することができる。ここにおいて記載された技術的事項の実装は、１つ以上のコンピュータプログラム製品、すなわち、データ処理装置による、またはデータ処理装置の動作を制御するための、有形および非一時的なコンピュータで読取り可能な媒体上に符号化されたコンピュータプログラム命令の１つ以上のモジュールとして実装することができる。コンピュータで読取り可能な媒体は、マシンで読取り可能な記憶装置、マシンで読取り可能な記憶基板、メモリ装置、マシンで読取り可能な伝搬信号に影響を与える物質の組成、または、それらの１つ以上の組み合わせであり得る。用語「データ処理ユニット」または「データ処理装置」は、例えば、プログラマブルプロセッサ、コンピュータ、または複数のプロセッサまたはコンピュータを含む、データを処理するための全ての装置、デバイス、およびマシンを包含する。装置は、ハードウェアに加えて、問題のコンピュータプログラムの実行環境を生成するコード、例えば、プロセッサファームウェア、プロトコルスタック、データベース管理システム、オペレーティングシステム、またはそれらの１つ以上の組み合わせを構成するコードを含むことができる。",
            "コンピュータプログラム(プログラム、ソフトウェア、ソフトウェアアプリケーション、スクリプト、またはコードとしても知られているもの)は、コンパイルまたはインタープリートされた言語を含む、任意の形態のプログラミング言語で書くことができ、それは、スタンドアロンプログラムとして、またはコンピューティング環境での使用に適したモジュール、コンポーネント、サブルーチン、または他のユニットとしてのものを含む、任意の形態で展開することができる。コンピュータプログラムは、必ずしもファイルシステム内のファイルに対応するものではない。プログラムは、他のプログラムまたはデータを保持するファイルの一部分(例えば、マークアップ言語文書に保管される１つ以上のスクリプト)、問題とされるプログラム専用の単一ファイル、または複数の調整されたファイル(例えば、１つ以上のモジュール、サブプログラム、またはコードの一部分を保管するファイル)に保管することができる。コンピュータプログラムは、１つのコンピュータまたは１つのサイトに配置されるか、または複数のサイトに分散され、通信ネットワークによって相互接続される複数のコンピュータ上で実行されるように展開することができる。",
            "ここにおいて説明されたプロセスおよび論理フローは、入力データ上で動作し、出力を生成することによって機能を実行するために、１つ以上のコンピュータプログラムを実行する、１つ以上のプログラマブルプロセッサによって実行することができる。プロセスおよび論理フローはまた、FPGA(フィールドプログラマブルゲートアレイ)またはASIC(特定用途向け集積回路)といった、特殊目的の論理回路によって実行することができ、装置も実行することができる。",
            "コンピュータプログラムの実行に適したプロセッサは、例えば、汎用および専用マイクロプロセッサの両方、および、任意の種類のデジタルコンピュータの任意の１つ以上のプロセッサを含む。一般的に、プロセッサは、リードオンリーメモリまたはランダムアクセスメモリ、もしくは、その両方から命令およびデータを受信する。コンピュータの必須要素は、命令を実行するためのプロセッサと、命令およびデータを保管するための１つ以上のメモリデバイスである。一般的に、コンピュータは、また、データを保管するための１つ以上の大容量記憶装置、例えば、磁気ディスク、磁気光ディスク、または光ディスクにデータを受信したり、データを転送したりするために動作可能に結合される。しかし、コンピュータは、そうした装置を有する必要はない。コンピュータプログラム命令およびデータを保管するのに適したコンピュータで読取り可能な媒体は、例えば、EPROM、EEPROM、およびフラッシュメモリデバイスといった、半導体メモリデバイスを含む、あらゆる形態の不揮発性メモリ、媒体およびメモリデバイスを含む。プロセッサおよびメモリは、特殊目的の論理回路によって補足されるか、または、内蔵され得る。",
            "本明細書は、図面と共に、単なる例示としてみなされる。ここで、例示は実施例を意味するものである。ここにおいて使用される場合、「または」の使用は、コンテキストが他のことを明確に示さない限り、「及び／又は」を含むことが意図されている。",
            "この特許文書には多くの詳細が含まれているが、これらは、いずれかの発明の範囲または特許請求される得るものを限定するものではなく、特定の発明の特定の実施形態に特有の特徴の説明であると解釈されるべきである。別々の実施形態のコンテキストにおいての特許文書に記載されている特定の特徴は、単一の実施形態において組み合わせて実施することもできる。逆に、単一の実施形態のコンテキストにおいて説明される種々の特徴は、複数の実施形態において別々に、または、任意の適切なサブコンビネーションで実施することもできる。さらに、特徴は、特定の組み合わせにおいて作用するものとして上述されており、最初にそのように請求されてもよいが、請求される組み合わせからの１つ以上の特徴は、場合によっては、組み合わせから切り出され得る。そして、請求される組み合わせは、サブコンビネーションまたはサブコンビネーションのバリエーションに向けられ得る。",
            "同様に、図面には特定の順序で動作が示されているが、これは、所望の結果を達成するために、そうした動作を特定の順序または順序で実行すること、または、例示された全ての動作を実行することを要求するものとして理解されるべきではない。さらに、この特許文書に記載されている実施形態における種々のシステムコンポーネントの分離は、全ての実施形態において、そうした分離を必要とするものとして理解されるべきではない。",
            "少数の実施形態および実施例だけが説明されており、この特許文書に記載され、説明されている内容に基づいて、他の実施形態、拡張、およびバリエーションが行われ得る。"
        ]
    }
}